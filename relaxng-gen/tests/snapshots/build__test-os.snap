---
source: relaxng-gen/tests/build.rs
expression: combined
---
--- acpi/table/type_choice.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeChoice {
    Raw,
    Rawset,
    Slic,
    Msdm,
}
impl ToXml for TypeChoice {
    type Builder = TypeChoiceBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Raw => {
                writer.write_event(Event::Text(BytesText::new("raw")))?;
            }
            Self::Rawset => {
                writer.write_event(Event::Text(BytesText::new("rawset")))?;
            }
            Self::Slic => {
                writer.write_event(Event::Text(BytesText::new("slic")))?;
            }
            Self::Msdm => {
                writer.write_event(Event::Text(BytesText::new("msdm")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for TypeChoice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl TypeChoice {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<TypeChoice> {
        let mut builder = TypeChoice::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "msdm" => {
                                builder.msdm()?;
                            }
                            "raw" => {
                                builder.raw()?;
                            }
                            "rawset" => {
                                builder.rawset()?;
                            }
                            "slic" => {
                                builder.slic()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Raw => {}
            Self::Rawset => {}
            Self::Slic => {}
            Self::Msdm => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for TypeChoice {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "msdm" => {
                builder.msdm()?;
            }
            "raw" => {
                builder.raw()?;
            }
            "rawset" => {
                builder.rawset()?;
            }
            "slic" => {
                builder.slic()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeChoiceBuilder {
    raw: Option<()>,
    rawset: Option<()>,
    slic: Option<()>,
    msdm: Option<()>,
}
impl TypeChoiceBuilder {
    pub fn raw(&mut self) -> Result<&mut Self> {
        self.raw = Some(());
        Ok(self)
    }
    pub fn rawset(&mut self) -> Result<&mut Self> {
        self.rawset = Some(());
        Ok(self)
    }
    pub fn slic(&mut self) -> Result<&mut Self> {
        self.slic = Some(());
        Ok(self)
    }
    pub fn msdm(&mut self) -> Result<&mut Self> {
        self.msdm = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<TypeChoice> {
        if self.raw.is_some() {
            return Ok(TypeChoice::Raw);
        }
        if self.rawset.is_some() {
            return Ok(TypeChoice::Rawset);
        }
        if self.slic.is_some() {
            return Ok(TypeChoice::Slic);
        }
        if self.msdm.is_some() {
            return Ok(TypeChoice::Msdm);
        }
        Err(Error::BuilderVariant("TypeChoice"))
    }
}

--- acpi/table.rs ---
//!`table` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod type_choice;
use type_choice::TypeChoice;
///`<table/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Table {
    pub r#type: TypeChoice,
    pub value: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern0,
    >,
}
impl ToXml for Table {
    type Builder = TableBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("table");
        {
            let elem = &self.r#type;
            xml_start
                .push_attribute((
                    &b"type"[..],
                    quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                ));
        }
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("table")))?;
        }
        Ok(())
    }
}
impl Table {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("type") {
            builder.r#type(TypeChoice::from_str(val)?)?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern0,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern0,
                                    >,
                                >()
                                .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Table {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<table/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct TableBuilder {
    pub r#type: Option<TypeChoice>,
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl TableBuilder {
    pub fn r#type<T>(&mut self, r#type: T) -> Result<&mut Self>
    where
        T: TryInto<TypeChoice>,
        Error: From<<T as TryInto<TypeChoice>>::Error>,
    {
        self.r#type = Some(r#type.try_into()?);
        Ok(self)
    }
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Table`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Table> {
        let r#type = Clone::clone(
            self.r#type.as_ref().ok_or(Error::BuilderMissingField("table", "r#type"))?,
        );
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("table", "value"))?,
        );
        Ok(Table { r#type, value })
    }
}

--- acpi.rs ---
//!`acpi` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod table;
use table::Table;
///`<acpi/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Acpi {
    pub tables: Vec<Table>,
}
impl ToXml for Acpi {
    type Builder = AcpiBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("acpi");
        let empty = {
            true
                && ({
                    let elem = &self.tables;
                    elem.iter().all(|elem| false)
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.tables;
                for elem in elem {
                    elem.to_xml(writer)?;
                }
            }
            writer.write_event(Event::End(BytesEnd::new("acpi")))?;
        }
        Ok(())
    }
}
impl Acpi {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                "table" if Table::from_xml(&child).is_ok() => {
                    builder.table(Table::from_xml(&child)?)?;
                }
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Acpi {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<acpi/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct AcpiBuilder {
    pub tables: Vec<Table>,
}
impl AcpiBuilder {
    pub fn table<T>(&mut self, table: T) -> Result<&mut Self>
    where
        T: TryInto<Table>,
        Error: From<<T as TryInto<Table>>::Error>,
    {
        self.tables.push(table.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Acpi`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Acpi> {
        let tables = Clone::clone(&self.tables);
        Ok(Acpi { tables })
    }
}

--- archnames.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Archnames {
    Aarch64,
    Alpha,
    Armv6l,
    Armv7l,
    Cris,
    I686,
    Ia64,
    Lm32,
    Loongarch64,
    M68k,
    Microblaze,
    Microblazeel,
    Mips,
    Mipsel,
    Mips64,
    Mips64el,
    Openrisc,
    Parisc,
    Parisc64,
    Ppc,
    Ppc64,
    Ppc64le,
    Ppcemb,
    Riscv32,
    Riscv64,
    S390,
    S390x,
    Sh4,
    Sh4eb,
    Sparc,
    Sparc64,
    Unicore32,
    X8664,
    Xtensa,
    Xtensaeb,
}
impl ToXml for Archnames {
    type Builder = ArchnamesBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Aarch64 => {
                writer.write_event(Event::Text(BytesText::new("aarch64")))?;
            }
            Self::Alpha => {
                writer.write_event(Event::Text(BytesText::new("alpha")))?;
            }
            Self::Armv6l => {
                writer.write_event(Event::Text(BytesText::new("armv6l")))?;
            }
            Self::Armv7l => {
                writer.write_event(Event::Text(BytesText::new("armv7l")))?;
            }
            Self::Cris => {
                writer.write_event(Event::Text(BytesText::new("cris")))?;
            }
            Self::I686 => {
                writer.write_event(Event::Text(BytesText::new("i686")))?;
            }
            Self::Ia64 => {
                writer.write_event(Event::Text(BytesText::new("ia64")))?;
            }
            Self::Lm32 => {
                writer.write_event(Event::Text(BytesText::new("lm32")))?;
            }
            Self::Loongarch64 => {
                writer.write_event(Event::Text(BytesText::new("loongarch64")))?;
            }
            Self::M68k => {
                writer.write_event(Event::Text(BytesText::new("m68k")))?;
            }
            Self::Microblaze => {
                writer.write_event(Event::Text(BytesText::new("microblaze")))?;
            }
            Self::Microblazeel => {
                writer.write_event(Event::Text(BytesText::new("microblazeel")))?;
            }
            Self::Mips => {
                writer.write_event(Event::Text(BytesText::new("mips")))?;
            }
            Self::Mipsel => {
                writer.write_event(Event::Text(BytesText::new("mipsel")))?;
            }
            Self::Mips64 => {
                writer.write_event(Event::Text(BytesText::new("mips64")))?;
            }
            Self::Mips64el => {
                writer.write_event(Event::Text(BytesText::new("mips64el")))?;
            }
            Self::Openrisc => {
                writer.write_event(Event::Text(BytesText::new("openrisc")))?;
            }
            Self::Parisc => {
                writer.write_event(Event::Text(BytesText::new("parisc")))?;
            }
            Self::Parisc64 => {
                writer.write_event(Event::Text(BytesText::new("parisc64")))?;
            }
            Self::Ppc => {
                writer.write_event(Event::Text(BytesText::new("ppc")))?;
            }
            Self::Ppc64 => {
                writer.write_event(Event::Text(BytesText::new("ppc64")))?;
            }
            Self::Ppc64le => {
                writer.write_event(Event::Text(BytesText::new("ppc64le")))?;
            }
            Self::Ppcemb => {
                writer.write_event(Event::Text(BytesText::new("ppcemb")))?;
            }
            Self::Riscv32 => {
                writer.write_event(Event::Text(BytesText::new("riscv32")))?;
            }
            Self::Riscv64 => {
                writer.write_event(Event::Text(BytesText::new("riscv64")))?;
            }
            Self::S390 => {
                writer.write_event(Event::Text(BytesText::new("s390")))?;
            }
            Self::S390x => {
                writer.write_event(Event::Text(BytesText::new("s390x")))?;
            }
            Self::Sh4 => {
                writer.write_event(Event::Text(BytesText::new("sh4")))?;
            }
            Self::Sh4eb => {
                writer.write_event(Event::Text(BytesText::new("sh4eb")))?;
            }
            Self::Sparc => {
                writer.write_event(Event::Text(BytesText::new("sparc")))?;
            }
            Self::Sparc64 => {
                writer.write_event(Event::Text(BytesText::new("sparc64")))?;
            }
            Self::Unicore32 => {
                writer.write_event(Event::Text(BytesText::new("unicore32")))?;
            }
            Self::X8664 => {
                writer.write_event(Event::Text(BytesText::new("x86_64")))?;
            }
            Self::Xtensa => {
                writer.write_event(Event::Text(BytesText::new("xtensa")))?;
            }
            Self::Xtensaeb => {
                writer.write_event(Event::Text(BytesText::new("xtensaeb")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for Archnames {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl Archnames {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<Archnames> {
        let mut builder = Archnames::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "aarch64" => {
                                builder.aarch64()?;
                            }
                            "alpha" => {
                                builder.alpha()?;
                            }
                            "armv6l" => {
                                builder.armv6l()?;
                            }
                            "armv7l" => {
                                builder.armv7l()?;
                            }
                            "cris" => {
                                builder.cris()?;
                            }
                            "i686" => {
                                builder.i686()?;
                            }
                            "ia64" => {
                                builder.ia64()?;
                            }
                            "lm32" => {
                                builder.lm32()?;
                            }
                            "loongarch64" => {
                                builder.loongarch64()?;
                            }
                            "m68k" => {
                                builder.m68k()?;
                            }
                            "microblaze" => {
                                builder.microblaze()?;
                            }
                            "microblazeel" => {
                                builder.microblazeel()?;
                            }
                            "mips" => {
                                builder.mips()?;
                            }
                            "mips64" => {
                                builder.mips64()?;
                            }
                            "mips64el" => {
                                builder.mips64el()?;
                            }
                            "mipsel" => {
                                builder.mipsel()?;
                            }
                            "openrisc" => {
                                builder.openrisc()?;
                            }
                            "parisc" => {
                                builder.parisc()?;
                            }
                            "parisc64" => {
                                builder.parisc64()?;
                            }
                            "ppc" => {
                                builder.ppc()?;
                            }
                            "ppc64" => {
                                builder.ppc64()?;
                            }
                            "ppc64le" => {
                                builder.ppc64le()?;
                            }
                            "ppcemb" => {
                                builder.ppcemb()?;
                            }
                            "riscv32" => {
                                builder.riscv32()?;
                            }
                            "riscv64" => {
                                builder.riscv64()?;
                            }
                            "s390" => {
                                builder.s390()?;
                            }
                            "s390x" => {
                                builder.s390x()?;
                            }
                            "sh4" => {
                                builder.sh4()?;
                            }
                            "sh4eb" => {
                                builder.sh4eb()?;
                            }
                            "sparc" => {
                                builder.sparc()?;
                            }
                            "sparc64" => {
                                builder.sparc64()?;
                            }
                            "unicore32" => {
                                builder.unicore32()?;
                            }
                            "x86_64" => {
                                builder.x86_64()?;
                            }
                            "xtensa" => {
                                builder.xtensa()?;
                            }
                            "xtensaeb" => {
                                builder.xtensaeb()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Aarch64 => {}
            Self::Alpha => {}
            Self::Armv6l => {}
            Self::Armv7l => {}
            Self::Cris => {}
            Self::I686 => {}
            Self::Ia64 => {}
            Self::Lm32 => {}
            Self::Loongarch64 => {}
            Self::M68k => {}
            Self::Microblaze => {}
            Self::Microblazeel => {}
            Self::Mips => {}
            Self::Mipsel => {}
            Self::Mips64 => {}
            Self::Mips64el => {}
            Self::Openrisc => {}
            Self::Parisc => {}
            Self::Parisc64 => {}
            Self::Ppc => {}
            Self::Ppc64 => {}
            Self::Ppc64le => {}
            Self::Ppcemb => {}
            Self::Riscv32 => {}
            Self::Riscv64 => {}
            Self::S390 => {}
            Self::S390x => {}
            Self::Sh4 => {}
            Self::Sh4eb => {}
            Self::Sparc => {}
            Self::Sparc64 => {}
            Self::Unicore32 => {}
            Self::X8664 => {}
            Self::Xtensa => {}
            Self::Xtensaeb => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for Archnames {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "aarch64" => {
                builder.aarch64()?;
            }
            "alpha" => {
                builder.alpha()?;
            }
            "armv6l" => {
                builder.armv6l()?;
            }
            "armv7l" => {
                builder.armv7l()?;
            }
            "cris" => {
                builder.cris()?;
            }
            "i686" => {
                builder.i686()?;
            }
            "ia64" => {
                builder.ia64()?;
            }
            "lm32" => {
                builder.lm32()?;
            }
            "loongarch64" => {
                builder.loongarch64()?;
            }
            "m68k" => {
                builder.m68k()?;
            }
            "microblaze" => {
                builder.microblaze()?;
            }
            "microblazeel" => {
                builder.microblazeel()?;
            }
            "mips" => {
                builder.mips()?;
            }
            "mips64" => {
                builder.mips64()?;
            }
            "mips64el" => {
                builder.mips64el()?;
            }
            "mipsel" => {
                builder.mipsel()?;
            }
            "openrisc" => {
                builder.openrisc()?;
            }
            "parisc" => {
                builder.parisc()?;
            }
            "parisc64" => {
                builder.parisc64()?;
            }
            "ppc" => {
                builder.ppc()?;
            }
            "ppc64" => {
                builder.ppc64()?;
            }
            "ppc64le" => {
                builder.ppc64le()?;
            }
            "ppcemb" => {
                builder.ppcemb()?;
            }
            "riscv32" => {
                builder.riscv32()?;
            }
            "riscv64" => {
                builder.riscv64()?;
            }
            "s390" => {
                builder.s390()?;
            }
            "s390x" => {
                builder.s390x()?;
            }
            "sh4" => {
                builder.sh4()?;
            }
            "sh4eb" => {
                builder.sh4eb()?;
            }
            "sparc" => {
                builder.sparc()?;
            }
            "sparc64" => {
                builder.sparc64()?;
            }
            "unicore32" => {
                builder.unicore32()?;
            }
            "x86_64" => {
                builder.x86_64()?;
            }
            "xtensa" => {
                builder.xtensa()?;
            }
            "xtensaeb" => {
                builder.xtensaeb()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArchnamesBuilder {
    aarch64: Option<()>,
    alpha: Option<()>,
    armv6l: Option<()>,
    armv7l: Option<()>,
    cris: Option<()>,
    i686: Option<()>,
    ia64: Option<()>,
    lm32: Option<()>,
    loongarch64: Option<()>,
    m68k: Option<()>,
    microblaze: Option<()>,
    microblazeel: Option<()>,
    mips: Option<()>,
    mipsel: Option<()>,
    mips64: Option<()>,
    mips64el: Option<()>,
    openrisc: Option<()>,
    parisc: Option<()>,
    parisc64: Option<()>,
    ppc: Option<()>,
    ppc64: Option<()>,
    ppc64le: Option<()>,
    ppcemb: Option<()>,
    riscv32: Option<()>,
    riscv64: Option<()>,
    s390: Option<()>,
    s390x: Option<()>,
    sh4: Option<()>,
    sh4eb: Option<()>,
    sparc: Option<()>,
    sparc64: Option<()>,
    unicore32: Option<()>,
    x86_64: Option<()>,
    xtensa: Option<()>,
    xtensaeb: Option<()>,
}
impl ArchnamesBuilder {
    pub fn aarch64(&mut self) -> Result<&mut Self> {
        self.aarch64 = Some(());
        Ok(self)
    }
    pub fn alpha(&mut self) -> Result<&mut Self> {
        self.alpha = Some(());
        Ok(self)
    }
    pub fn armv6l(&mut self) -> Result<&mut Self> {
        self.armv6l = Some(());
        Ok(self)
    }
    pub fn armv7l(&mut self) -> Result<&mut Self> {
        self.armv7l = Some(());
        Ok(self)
    }
    pub fn cris(&mut self) -> Result<&mut Self> {
        self.cris = Some(());
        Ok(self)
    }
    pub fn i686(&mut self) -> Result<&mut Self> {
        self.i686 = Some(());
        Ok(self)
    }
    pub fn ia64(&mut self) -> Result<&mut Self> {
        self.ia64 = Some(());
        Ok(self)
    }
    pub fn lm32(&mut self) -> Result<&mut Self> {
        self.lm32 = Some(());
        Ok(self)
    }
    pub fn loongarch64(&mut self) -> Result<&mut Self> {
        self.loongarch64 = Some(());
        Ok(self)
    }
    pub fn m68k(&mut self) -> Result<&mut Self> {
        self.m68k = Some(());
        Ok(self)
    }
    pub fn microblaze(&mut self) -> Result<&mut Self> {
        self.microblaze = Some(());
        Ok(self)
    }
    pub fn microblazeel(&mut self) -> Result<&mut Self> {
        self.microblazeel = Some(());
        Ok(self)
    }
    pub fn mips(&mut self) -> Result<&mut Self> {
        self.mips = Some(());
        Ok(self)
    }
    pub fn mipsel(&mut self) -> Result<&mut Self> {
        self.mipsel = Some(());
        Ok(self)
    }
    pub fn mips64(&mut self) -> Result<&mut Self> {
        self.mips64 = Some(());
        Ok(self)
    }
    pub fn mips64el(&mut self) -> Result<&mut Self> {
        self.mips64el = Some(());
        Ok(self)
    }
    pub fn openrisc(&mut self) -> Result<&mut Self> {
        self.openrisc = Some(());
        Ok(self)
    }
    pub fn parisc(&mut self) -> Result<&mut Self> {
        self.parisc = Some(());
        Ok(self)
    }
    pub fn parisc64(&mut self) -> Result<&mut Self> {
        self.parisc64 = Some(());
        Ok(self)
    }
    pub fn ppc(&mut self) -> Result<&mut Self> {
        self.ppc = Some(());
        Ok(self)
    }
    pub fn ppc64(&mut self) -> Result<&mut Self> {
        self.ppc64 = Some(());
        Ok(self)
    }
    pub fn ppc64le(&mut self) -> Result<&mut Self> {
        self.ppc64le = Some(());
        Ok(self)
    }
    pub fn ppcemb(&mut self) -> Result<&mut Self> {
        self.ppcemb = Some(());
        Ok(self)
    }
    pub fn riscv32(&mut self) -> Result<&mut Self> {
        self.riscv32 = Some(());
        Ok(self)
    }
    pub fn riscv64(&mut self) -> Result<&mut Self> {
        self.riscv64 = Some(());
        Ok(self)
    }
    pub fn s390(&mut self) -> Result<&mut Self> {
        self.s390 = Some(());
        Ok(self)
    }
    pub fn s390x(&mut self) -> Result<&mut Self> {
        self.s390x = Some(());
        Ok(self)
    }
    pub fn sh4(&mut self) -> Result<&mut Self> {
        self.sh4 = Some(());
        Ok(self)
    }
    pub fn sh4eb(&mut self) -> Result<&mut Self> {
        self.sh4eb = Some(());
        Ok(self)
    }
    pub fn sparc(&mut self) -> Result<&mut Self> {
        self.sparc = Some(());
        Ok(self)
    }
    pub fn sparc64(&mut self) -> Result<&mut Self> {
        self.sparc64 = Some(());
        Ok(self)
    }
    pub fn unicore32(&mut self) -> Result<&mut Self> {
        self.unicore32 = Some(());
        Ok(self)
    }
    pub fn x86_64(&mut self) -> Result<&mut Self> {
        self.x86_64 = Some(());
        Ok(self)
    }
    pub fn xtensa(&mut self) -> Result<&mut Self> {
        self.xtensa = Some(());
        Ok(self)
    }
    pub fn xtensaeb(&mut self) -> Result<&mut Self> {
        self.xtensaeb = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<Archnames> {
        if self.aarch64.is_some() {
            return Ok(Archnames::Aarch64);
        }
        if self.alpha.is_some() {
            return Ok(Archnames::Alpha);
        }
        if self.armv6l.is_some() {
            return Ok(Archnames::Armv6l);
        }
        if self.armv7l.is_some() {
            return Ok(Archnames::Armv7l);
        }
        if self.cris.is_some() {
            return Ok(Archnames::Cris);
        }
        if self.i686.is_some() {
            return Ok(Archnames::I686);
        }
        if self.ia64.is_some() {
            return Ok(Archnames::Ia64);
        }
        if self.lm32.is_some() {
            return Ok(Archnames::Lm32);
        }
        if self.loongarch64.is_some() {
            return Ok(Archnames::Loongarch64);
        }
        if self.m68k.is_some() {
            return Ok(Archnames::M68k);
        }
        if self.microblaze.is_some() {
            return Ok(Archnames::Microblaze);
        }
        if self.microblazeel.is_some() {
            return Ok(Archnames::Microblazeel);
        }
        if self.mips.is_some() {
            return Ok(Archnames::Mips);
        }
        if self.mipsel.is_some() {
            return Ok(Archnames::Mipsel);
        }
        if self.mips64.is_some() {
            return Ok(Archnames::Mips64);
        }
        if self.mips64el.is_some() {
            return Ok(Archnames::Mips64el);
        }
        if self.openrisc.is_some() {
            return Ok(Archnames::Openrisc);
        }
        if self.parisc.is_some() {
            return Ok(Archnames::Parisc);
        }
        if self.parisc64.is_some() {
            return Ok(Archnames::Parisc64);
        }
        if self.ppc.is_some() {
            return Ok(Archnames::Ppc);
        }
        if self.ppc64.is_some() {
            return Ok(Archnames::Ppc64);
        }
        if self.ppc64le.is_some() {
            return Ok(Archnames::Ppc64le);
        }
        if self.ppcemb.is_some() {
            return Ok(Archnames::Ppcemb);
        }
        if self.riscv32.is_some() {
            return Ok(Archnames::Riscv32);
        }
        if self.riscv64.is_some() {
            return Ok(Archnames::Riscv64);
        }
        if self.s390.is_some() {
            return Ok(Archnames::S390);
        }
        if self.s390x.is_some() {
            return Ok(Archnames::S390x);
        }
        if self.sh4.is_some() {
            return Ok(Archnames::Sh4);
        }
        if self.sh4eb.is_some() {
            return Ok(Archnames::Sh4eb);
        }
        if self.sparc.is_some() {
            return Ok(Archnames::Sparc);
        }
        if self.sparc64.is_some() {
            return Ok(Archnames::Sparc64);
        }
        if self.unicore32.is_some() {
            return Ok(Archnames::Unicore32);
        }
        if self.x86_64.is_some() {
            return Ok(Archnames::X8664);
        }
        if self.xtensa.is_some() {
            return Ok(Archnames::Xtensa);
        }
        if self.xtensaeb.is_some() {
            return Ok(Archnames::Xtensaeb);
        }
        Err(Error::BuilderVariant("Archnames"))
    }
}

--- bios.rs ---
//!`bios` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
use crate::vir_yes_no::VirYesNo;
///`<bios/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Bios {
    pub useserial: Option<VirYesNo>,
    pub reboot_timeout: Option<bounded_integer::BoundedI16<-1i16, 32767i16>>,
}
impl ToXml for Bios {
    type Builder = BiosBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("bios");
        {
            let elem = &self.useserial;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"useserial"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        {
            let elem = &self.reboot_timeout;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"rebootTimeout"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        let empty = { true };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            writer.write_event(Event::End(BytesEnd::new("bios")))?;
        }
        Ok(())
    }
}
impl Bios {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("useserial") {
            builder.useserial(Some(VirYesNo::from_str(val)?))?;
        }
        if let Some(val) = node.attribute("rebootTimeout") {
            builder
                .reboot_timeout(
                    Some(
                        val
                            .parse::<bounded_integer::BoundedI16<-1i16, 32767i16>>()
                            .map_err(|e| Error::ParseError(
                                "reboot_timeout",
                                Box::new(e),
                            ))?,
                    ),
                )?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Bios {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<bios/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BiosBuilder {
    pub useserial: Option<VirYesNo>,
    pub reboot_timeout: Option<bounded_integer::BoundedI16<-1i16, 32767i16>>,
}
impl BiosBuilder {
    pub fn useserial<T>(&mut self, useserial: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<VirYesNo>,
        Error: From<<T as TryInto<VirYesNo>>::Error>,
    {
        self.useserial = if let Some(useserial) = useserial {
            Some(useserial.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn reboot_timeout<T>(&mut self, reboot_timeout: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<bounded_integer::BoundedI16<-1i16, 32767i16>>,
        Error: From<<T as TryInto<bounded_integer::BoundedI16<-1i16, 32767i16>>>::Error>,
    {
        self.reboot_timeout = if let Some(reboot_timeout) = reboot_timeout {
            Some(reboot_timeout.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    /**
            Attempt to build [`Bios`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Bios> {
        let useserial = Clone::clone(&self.useserial);
        let reboot_timeout = Clone::clone(&self.reboot_timeout);
        Ok(Bios { useserial, reboot_timeout })
    }
}

--- boot/dev_choice.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DevChoice {
    Hd,
    Fd,
    Cdrom,
    Network,
}
impl ToXml for DevChoice {
    type Builder = DevChoiceBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Hd => {
                writer.write_event(Event::Text(BytesText::new("hd")))?;
            }
            Self::Fd => {
                writer.write_event(Event::Text(BytesText::new("fd")))?;
            }
            Self::Cdrom => {
                writer.write_event(Event::Text(BytesText::new("cdrom")))?;
            }
            Self::Network => {
                writer.write_event(Event::Text(BytesText::new("network")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for DevChoice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl DevChoice {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<DevChoice> {
        let mut builder = DevChoice::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "cdrom" => {
                                builder.cdrom()?;
                            }
                            "fd" => {
                                builder.fd()?;
                            }
                            "hd" => {
                                builder.hd()?;
                            }
                            "network" => {
                                builder.network()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Hd => {}
            Self::Fd => {}
            Self::Cdrom => {}
            Self::Network => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for DevChoice {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "cdrom" => {
                builder.cdrom()?;
            }
            "fd" => {
                builder.fd()?;
            }
            "hd" => {
                builder.hd()?;
            }
            "network" => {
                builder.network()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct DevChoiceBuilder {
    hd: Option<()>,
    fd: Option<()>,
    cdrom: Option<()>,
    network: Option<()>,
}
impl DevChoiceBuilder {
    pub fn hd(&mut self) -> Result<&mut Self> {
        self.hd = Some(());
        Ok(self)
    }
    pub fn fd(&mut self) -> Result<&mut Self> {
        self.fd = Some(());
        Ok(self)
    }
    pub fn cdrom(&mut self) -> Result<&mut Self> {
        self.cdrom = Some(());
        Ok(self)
    }
    pub fn network(&mut self) -> Result<&mut Self> {
        self.network = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<DevChoice> {
        if self.hd.is_some() {
            return Ok(DevChoice::Hd);
        }
        if self.fd.is_some() {
            return Ok(DevChoice::Fd);
        }
        if self.cdrom.is_some() {
            return Ok(DevChoice::Cdrom);
        }
        if self.network.is_some() {
            return Ok(DevChoice::Network);
        }
        Err(Error::BuilderVariant("DevChoice"))
    }
}

--- boot.rs ---
//!`boot` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod dev_choice;
use dev_choice::DevChoice;
///`<boot/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Boot {
    pub dev: DevChoice,
}
impl ToXml for Boot {
    type Builder = BootBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("boot");
        {
            let elem = &self.dev;
            xml_start
                .push_attribute((
                    &b"dev"[..],
                    quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                ));
        }
        let empty = { true };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            writer.write_event(Event::End(BytesEnd::new("boot")))?;
        }
        Ok(())
    }
}
impl Boot {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("dev") {
            builder.dev(DevChoice::from_str(val)?)?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Boot {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<boot/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BootBuilder {
    pub dev: Option<DevChoice>,
}
impl BootBuilder {
    pub fn dev<T>(&mut self, dev: T) -> Result<&mut Self>
    where
        T: TryInto<DevChoice>,
        Error: From<<T as TryInto<DevChoice>>::Error>,
    {
        self.dev = Some(dev.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Boot`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Boot> {
        let dev = Clone::clone(
            self.dev.as_ref().ok_or(Error::BuilderMissingField("boot", "dev"))?,
        );
        Ok(Boot { dev })
    }
}

--- bootloader/bootloader_choice.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BootloaderChoice {
    Value(String),
    Empty,
}
impl ToXml for BootloaderChoice {
    type Builder = BootloaderChoiceBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Value(value) => {
                let elem = value;
                {
                    let elem = value;
                    writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
                }
            }
            Self::Empty => {}
        }
        Ok(())
    }
}
impl core::fmt::Display for BootloaderChoice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl BootloaderChoice {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<BootloaderChoice> {
        let mut builder = BootloaderChoice::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            _ => {
                                builder.value(val)?;
                            }
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Value(value) => {
                let elem = value;
            }
            Self::Empty => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for BootloaderChoice {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "" => {
                builder.empty()?;
            }
            val => {
                builder.value(val)?;
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BootloaderChoiceBuilder {
    value: Option<String>,
    empty: Option<()>,
}
impl BootloaderChoiceBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<String>,
        Error: From<<T as TryInto<String>>::Error>,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    pub fn empty(&mut self) -> Result<&mut Self> {
        self.empty = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<BootloaderChoice> {
        if self.value.is_some() {
            return Ok(
                BootloaderChoice::Value(Clone::clone(&self.value.as_ref().unwrap())),
            );
        }
        if self.empty.is_some() {
            return Ok(BootloaderChoice::Empty);
        }
        Ok(BootloaderChoice::Empty)
    }
}

--- bootloader.rs ---
//!`bootloader` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod bootloader_choice;
use bootloader_choice::BootloaderChoice;
///`<bootloader/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Bootloader {
    pub bootloader_choice: BootloaderChoice,
}
impl ToXml for Bootloader {
    type Builder = BootloaderBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("bootloader");
        {
            let elem = &self.bootloader_choice;
            elem.to_xml_attr(&mut xml_start)?;
        }
        let empty = {
            true
                && ({
                    let elem = &self.bootloader_choice;
                    elem.is_empty()
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.bootloader_choice;
                elem.to_xml(writer)?;
            }
            writer.write_event(Event::End(BytesEnd::new("bootloader")))?;
        }
        Ok(())
    }
}
impl Bootloader {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        let child = &mut node.first_child();
        if let Ok(val) = BootloaderChoice::from_xml(node, child) {
            builder.bootloader_choice(val)?;
        }
        builder.build()
    }
}
impl core::fmt::Display for Bootloader {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<bootloader/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BootloaderBuilder {
    pub bootloader_choice: Option<BootloaderChoice>,
}
impl BootloaderBuilder {
    pub fn bootloader_choice<T>(&mut self, bootloader_choice: T) -> Result<&mut Self>
    where
        T: TryInto<BootloaderChoice>,
        Error: From<<T as TryInto<BootloaderChoice>>::Error>,
    {
        self.bootloader_choice = Some(bootloader_choice.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Bootloader`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Bootloader> {
        let bootloader_choice = Clone::clone(
            self
                .bootloader_choice
                .as_ref()
                .ok_or(Error::BuilderMissingField("bootloader", "bootloader_choice"))?,
        );
        Ok(Bootloader { bootloader_choice })
    }
}

--- bootloader_args.rs ---
//!`bootloader_args` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<bootloader_args/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BootloaderArgs {
    pub value: String,
}
impl ToXml for BootloaderArgs {
    type Builder = BootloaderArgsBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("bootloader_args");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("bootloader_args")))?;
        }
        Ok(())
    }
}
impl BootloaderArgs {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {
                    builder.value(val)?;
                }
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for BootloaderArgs {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<bootloader_args/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BootloaderArgsBuilder {
    pub value: Option<String>,
}
impl BootloaderArgsBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<String>,
        Error: From<<T as TryInto<String>>::Error>,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`BootloaderArgs`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<BootloaderArgs> {
        let value = Clone::clone(
            self
                .value
                .as_ref()
                .ok_or(Error::BuilderMissingField("bootloader_args", "value"))?,
        );
        Ok(BootloaderArgs { value })
    }
}

--- cmdline.rs ---
//!`cmdline` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<cmdline/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Cmdline {
    pub value: String,
}
impl ToXml for Cmdline {
    type Builder = CmdlineBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("cmdline");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("cmdline")))?;
        }
        Ok(())
    }
}
impl Cmdline {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {
                    builder.value(val)?;
                }
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Cmdline {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<cmdline/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct CmdlineBuilder {
    pub value: Option<String>,
}
impl CmdlineBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<String>,
        Error: From<<T as TryInto<String>>::Error>,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Cmdline`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Cmdline> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("cmdline", "value"))?,
        );
        Ok(Cmdline { value })
    }
}

--- dtb.rs ---
//!`dtb` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<dtb/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Dtb {
    pub value: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern0,
    >,
}
impl ToXml for Dtb {
    type Builder = DtbBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("dtb");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("dtb")))?;
        }
        Ok(())
    }
}
impl Dtb {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern0,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern0,
                                    >,
                                >()
                                .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Dtb {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<dtb/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct DtbBuilder {
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl DtbBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Dtb`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Dtb> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("dtb", "value"))?,
        );
        Ok(Dtb { value })
    }
}

--- initrd.rs ---
//!`initrd` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<initrd/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Initrd {
    pub value: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern0,
    >,
}
impl ToXml for Initrd {
    type Builder = InitrdBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("initrd");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("initrd")))?;
        }
        Ok(())
    }
}
impl Initrd {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern0,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern0,
                                    >,
                                >()
                                .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Initrd {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<initrd/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct InitrdBuilder {
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl InitrdBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Initrd`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Initrd> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("initrd", "value"))?,
        );
        Ok(Initrd { value })
    }
}

--- kernel.rs ---
//!`kernel` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<kernel/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Kernel {
    pub value: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern0,
    >,
}
impl ToXml for Kernel {
    type Builder = KernelBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("kernel");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("kernel")))?;
        }
        Ok(())
    }
}
impl Kernel {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern0,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern0,
                                    >,
                                >()
                                .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Kernel {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<kernel/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct KernelBuilder {
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl KernelBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Kernel`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Kernel> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("kernel", "value"))?,
        );
        Ok(Kernel { value })
    }
}

--- lib.rs ---
#![doc = concat!(
    "Generated from ",
    "'/home/elmarco/src/relaxng-rust/relaxng-gen/tests/fixtures/os.rng'", " schema."
)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use thiserror::Error;
pub mod acpi;
pub mod archnames;
pub mod bios;
pub mod boot;
pub mod bootloader;
pub mod bootloader_args;
pub mod cmdline;
pub mod dtb;
pub mod initrd;
pub mod kernel;
pub mod os;
pub mod os_exe;
pub mod os_hvm;
pub mod osxen;
pub mod pflash_format_types;
pub mod r#type;
pub mod root;
pub mod shim;
pub mod smbios;
pub mod vir_yes_no;
pub use os::*;
/// The error type used by this crate.
#[derive(Error, Debug)]
pub enum Error {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("From UTF-8 error: {0}")]
    FromUtf8Error(#[from] std::string::FromUtf8Error),
    #[error("{0} builder is missing mandatory field: {1}")]
    BuilderMissingField(&'static str, &'static str),
    #[error("{0} builder cannot build a variant")]
    BuilderVariant(&'static str),
    #[error("String too short, expected at least {0} characters, got {1}")]
    TooShort(usize, usize),
    #[error("String too long, expected at most {0} characters, got {1}")]
    TooLong(usize, usize),
    #[error("String '{1}' does not match pattern '{0}'")]
    PatternMismatch(&'static str, String),
    #[error("Failed to compile regex: {0}")]
    RegexError(#[from] regex::Error),
    #[error("Failed to parse '{0}': {1}")]
    ParseError(
        &'static str,
        #[source]
        Box<dyn std::error::Error + Send + Sync + 'static>,
    ),
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!("Infallible error should not occur")
    }
}
/// Helper trait for this crate XML types.
pub trait ToXml {
    /// The associated builder type.
    type Builder: Default;
    /// Creates a new builder for this type.
    fn builder() -> Self::Builder {
        Self::Builder::default()
    }
    /// Writes Events to a XML writer.
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write;
}
#[doc(hidden)]
pub trait RegexPattern {
    const REGEX: &'static str;
}
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NoPattern;
impl RegexPattern for NoPattern {
    const REGEX: &'static str = "";
}
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RegexPattern0;
impl RegexPattern for RegexPattern0 {
    const REGEX: &'static str = "(/|[a-zA-Z]:\\\\).+";
}
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RegexPattern3;
impl RegexPattern for RegexPattern3 {
    const REGEX: &'static str = "[a-zA-Z0-9_\\+\\-]+";
}
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RegexPattern1;
impl RegexPattern for RegexPattern1 {
    const REGEX: &'static str = "[a-zA-Z0-9_\\.\\-]+";
}
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RegexPattern2;
impl RegexPattern for RegexPattern2 {
    const REGEX: &'static str = "[a-zA-Z_]+[a-zA-Z0-9_]*";
}
/// A string type with length constraints and optional runtime regex validation.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstrainedString<
    const MIN_LEN: usize,
    const MAX_LEN: usize,
    P: RegexPattern = NoPattern,
> {
    value: String,
    _phantom: std::marker::PhantomData<P>,
}
impl<
    const MIN: usize,
    const MAX: usize,
    P: RegexPattern,
> ConstrainedString<MIN, MAX, P> {
    pub const NO_MIN_CONSTRAINT: usize = 0;
    pub const NO_MAX_CONSTRAINT: usize = usize::MAX;
    pub fn try_new(value: impl Into<String>) -> Result<Self> {
        let s = value.into();
        Self::validate(&s)?;
        Ok(Self {
            value: s,
            _phantom: std::marker::PhantomData,
        })
    }
    fn validate(s: &str) -> Result<()> {
        fn get_compiled_regex(pattern: &'static str) -> Result<regex::Regex> {
            /// Registry for compiled regex patterns
            static REGEX_REGISTRY: std::sync::OnceLock<
                std::sync::Mutex<std::collections::HashMap<&'static str, regex::Regex>>,
            > = std::sync::OnceLock::new();
            if pattern.is_empty() {
                return Ok(regex::Regex::new(".*").unwrap());
            }
            let registry = REGEX_REGISTRY
                .get_or_init(|| std::sync::Mutex::new(std::collections::HashMap::new()));
            let mut map = registry.lock().unwrap();
            if let Some(regex) = map.get(pattern) {
                return Ok(regex.clone());
            }
            match regex::Regex::new(pattern) {
                Ok(regex) => {
                    let result = regex.clone();
                    map.insert(pattern, regex);
                    Ok(result)
                }
                Err(e) => Err(Error::RegexError(e)),
            }
        }
        if MIN > Self::NO_MIN_CONSTRAINT && s.len() < MIN {
            return Err(Error::TooShort(MIN, s.len()));
        }
        if MAX < Self::NO_MAX_CONSTRAINT && s.len() > MAX {
            return Err(Error::TooLong(MAX, s.len()));
        }
        if !P::REGEX.is_empty() {
            let regex = get_compiled_regex(P::REGEX)?;
            if !regex.is_match(s) {
                return Err(Error::PatternMismatch(P::REGEX, s.to_string()));
            }
        }
        Ok(())
    }
    /// Returns the string as a `&str`.
    #[must_use]
    pub fn as_str(&self) -> &str {
        &self.value
    }
    /// Converts the constrained string into a `String`, consuming it.
    #[must_use]
    pub fn into_string(self) -> String {
        self.value
    }
}
impl<const MIN: usize, const MAX: usize, P: RegexPattern> std::ops::Deref
for ConstrainedString<MIN, MAX, P> {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        &self.value
    }
}
impl<const MIN: usize, const MAX: usize, P: RegexPattern> std::fmt::Display
for ConstrainedString<MIN, MAX, P> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.value)
    }
}
impl<const MIN: usize, const MAX: usize, P: RegexPattern> AsRef<str>
for ConstrainedString<MIN, MAX, P> {
    fn as_ref(&self) -> &str {
        &self.value
    }
}
impl<const MIN: usize, const MAX: usize, P: RegexPattern> std::str::FromStr
for ConstrainedString<MIN, MAX, P> {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        Self::try_new(s)
    }
}
impl<const MIN: usize, const MAX: usize, P: RegexPattern> TryFrom<&str>
for ConstrainedString<MIN, MAX, P> {
    type Error = Error;
    fn try_from(s: &str) -> Result<Self> {
        Self::try_new(s)
    }
}
/// A specialized Result type where the error is hard-wired to [`enum@Error`].
pub type Result<T, E = Error> = std::result::Result<T, E>;

--- main.rs ---
use std::path::Path;
use std::{env::args, fs};
fn main() {
    let path = args().nth(1).expect("No XML file path provided");
    let xml_path = Path::new(&path);
    let xml = fs::read_to_string(xml_path).expect("Failed to read test XML file");
    let xml = roxmltree::Document::parse(&xml).expect("Failed to parse XML");
    let root = xml.root().first_child().expect("No root element found");
    let mut child = Some(root);
    let res = test_os::Os::from_xml(&root, &mut child).unwrap();
    let res = res.to_string();
    println!("{}", res);
}

--- os.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
use crate::bootloader::Bootloader;
use crate::bootloader_args::BootloaderArgs;
use crate::os_exe::OsExe;
use crate::os_hvm::OsHvm;
use crate::osxen::Osxen;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Os {
    Osxen(Osxen),
    OsExe(OsExe),
    #[doc = "/ref[@name='oshvm']/interleave[1]"]
    Variant0 {
        bootloader: Option<Bootloader>,
        bootloader_args: Option<BootloaderArgs>,
        os_hvm: OsHvm,
    },
}
impl ToXml for Os {
    type Builder = OsBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Osxen(osxen) => {
                let elem = osxen;
                {
                    let elem = osxen;
                    elem.to_xml(writer)?;
                }
            }
            Self::OsExe(os_exe) => {
                let elem = os_exe;
                {
                    let elem = os_exe;
                    elem.to_xml(writer)?;
                }
            }
            Self::Variant0 { bootloader, bootloader_args, os_hvm } => {
                {
                    let elem = bootloader;
                    if let Some(elem) = elem {
                        elem.to_xml(writer)?;
                    }
                }
                {
                    let elem = bootloader_args;
                    if let Some(elem) = elem {
                        elem.to_xml(writer)?;
                    }
                }
                {
                    let elem = os_hvm;
                    elem.to_xml(writer)?;
                }
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for Os {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl Os {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<Os> {
        let mut builder = Os::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        "bootloader" if Bootloader::from_xml(&child).is_ok() => {
                            builder.bootloader(Some(Bootloader::from_xml(&child)?))?;
                        }
                        "bootloader_args" if BootloaderArgs::from_xml(&child)
                            .is_ok() => {
                            builder
                                .bootloader_args(Some(BootloaderArgs::from_xml(&child)?))?;
                        }
                        "os" if OsHvm::from_xml(&child).is_ok() => {
                            builder.os_hvm(OsHvm::from_xml(&child)?)?;
                        }
                        "os" if OsExe::from_xml(&child).is_ok() => {
                            builder.os_exe(OsExe::from_xml(&child)?)?;
                        }
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
        }
        let child = &mut node.first_child();
        if let Ok(val) = Osxen::from_xml(node, child) {
            builder.osxen(val)?;
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Osxen(osxen) => {
                let elem = osxen;
                {
                    let elem = osxen;
                    elem.to_xml_attr(xml_start)?;
                }
            }
            Self::OsExe(os_exe) => {
                let elem = os_exe;
            }
            Self::Variant0 { bootloader, bootloader_args, os_hvm } => {
                let elem = bootloader;
                let elem = bootloader_args;
                let elem = os_hvm;
            }
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct OsBuilder {
    osxen: Option<Osxen>,
    bootloader: Option<Bootloader>,
    bootloader_args: Option<BootloaderArgs>,
    os_hvm: Option<OsHvm>,
    os_exe: Option<OsExe>,
}
impl OsBuilder {
    pub fn osxen<T>(&mut self, osxen: T) -> Result<&mut Self>
    where
        T: TryInto<Osxen>,
        Error: From<<T as TryInto<Osxen>>::Error>,
    {
        self.osxen = Some(osxen.try_into()?);
        Ok(self)
    }
    pub fn bootloader<T>(&mut self, bootloader: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Bootloader>,
        Error: From<<T as TryInto<Bootloader>>::Error>,
    {
        self.bootloader = if let Some(bootloader) = bootloader {
            Some(bootloader.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn bootloader_args<T>(&mut self, bootloader_args: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<BootloaderArgs>,
        Error: From<<T as TryInto<BootloaderArgs>>::Error>,
    {
        self.bootloader_args = if let Some(bootloader_args) = bootloader_args {
            Some(bootloader_args.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn os_hvm<T>(&mut self, os_hvm: T) -> Result<&mut Self>
    where
        T: TryInto<OsHvm>,
        Error: From<<T as TryInto<OsHvm>>::Error>,
    {
        self.os_hvm = Some(os_hvm.try_into()?);
        Ok(self)
    }
    pub fn os_exe<T>(&mut self, os_exe: T) -> Result<&mut Self>
    where
        T: TryInto<OsExe>,
        Error: From<<T as TryInto<OsExe>>::Error>,
    {
        self.os_exe = Some(os_exe.try_into()?);
        Ok(self)
    }
    pub fn build(&self) -> Result<Os> {
        if self.os_hvm.is_some() {
            return Ok(Os::Variant0 {
                bootloader: Clone::clone(&self.bootloader).into(),
                bootloader_args: Clone::clone(&self.bootloader_args).into(),
                os_hvm: Clone::clone(self.os_hvm.as_ref().unwrap()).into(),
            });
        }
        if self.osxen.is_some() {
            return Ok(Os::Osxen(Clone::clone(&self.osxen.as_ref().unwrap())));
        }
        if self.os_exe.is_some() {
            return Ok(Os::OsExe(Clone::clone(&self.os_exe.as_ref().unwrap())));
        }
        Err(Error::BuilderVariant("Os"))
    }
}

--- os_exe/init.rs ---
//!`init` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<init/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Init {
    pub value: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern0,
    >,
}
impl ToXml for Init {
    type Builder = InitBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("init");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("init")))?;
        }
        Ok(())
    }
}
impl Init {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern0,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern0,
                                    >,
                                >()
                                .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Init {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<init/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct InitBuilder {
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl InitBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Init`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Init> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("init", "value"))?,
        );
        Ok(Init { value })
    }
}

--- os_exe/initarg.rs ---
//!`initarg` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<initarg/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Initarg {
    pub value: String,
}
impl ToXml for Initarg {
    type Builder = InitargBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("initarg");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("initarg")))?;
        }
        Ok(())
    }
}
impl Initarg {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {
                    builder.value(val)?;
                }
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Initarg {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<initarg/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct InitargBuilder {
    pub value: Option<String>,
}
impl InitargBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<String>,
        Error: From<<T as TryInto<String>>::Error>,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Initarg`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Initarg> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("initarg", "value"))?,
        );
        Ok(Initarg { value })
    }
}

--- os_exe/initdir.rs ---
//!`initdir` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<initdir/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Initdir {
    pub value: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern0,
    >,
}
impl ToXml for Initdir {
    type Builder = InitdirBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("initdir");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("initdir")))?;
        }
        Ok(())
    }
}
impl Initdir {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern0,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern0,
                                    >,
                                >()
                                .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Initdir {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<initdir/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct InitdirBuilder {
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl InitdirBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Initdir`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Initdir> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("initdir", "value"))?,
        );
        Ok(Initdir { value })
    }
}

--- os_exe/initenv.rs ---
//!`initenv` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<initenv/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Initenv {
    pub name: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern2,
    >,
    pub value: String,
}
impl ToXml for Initenv {
    type Builder = InitenvBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("initenv");
        {
            let elem = &self.name;
            xml_start
                .push_attribute((
                    &b"name"[..],
                    quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                ));
        }
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("initenv")))?;
        }
        Ok(())
    }
}
impl Initenv {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("name") {
            builder
                .name(
                    val
                        .parse::<
                            crate::ConstrainedString<
                                0usize,
                                18446744073709551615usize,
                                crate::RegexPattern2,
                            >,
                        >()
                        .map_err(|e| Error::ParseError("name", Box::new(e)))?,
                )?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {
                    builder.value(val)?;
                }
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Initenv {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<initenv/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct InitenvBuilder {
    pub name: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern2>,
    >,
    pub value: Option<String>,
}
impl InitenvBuilder {
    pub fn name<T>(&mut self, name: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern2,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern2,
                >,
            >>::Error,
        >,
    {
        self.name = Some(name.try_into()?);
        Ok(self)
    }
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<String>,
        Error: From<<T as TryInto<String>>::Error>,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Initenv`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Initenv> {
        let name = Clone::clone(
            self.name.as_ref().ok_or(Error::BuilderMissingField("initenv", "name"))?,
        );
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("initenv", "value"))?,
        );
        Ok(Initenv { name, value })
    }
}

--- os_exe/initgroup.rs ---
//!`initgroup` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<initgroup/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Initgroup {
    pub value: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern3,
    >,
}
impl ToXml for Initgroup {
    type Builder = InitgroupBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("initgroup");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("initgroup")))?;
        }
        Ok(())
    }
}
impl Initgroup {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern3,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern3,
                                    >,
                                >()
                                .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Initgroup {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<initgroup/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct InitgroupBuilder {
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern3>,
    >,
}
impl InitgroupBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern3,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern3,
                >,
            >>::Error,
        >,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Initgroup`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Initgroup> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("initgroup", "value"))?,
        );
        Ok(Initgroup { value })
    }
}

--- os_exe/inituser.rs ---
//!`inituser` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<inituser/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Inituser {
    pub value: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern3,
    >,
}
impl ToXml for Inituser {
    type Builder = InituserBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("inituser");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("inituser")))?;
        }
        Ok(())
    }
}
impl Inituser {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern3,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern3,
                                    >,
                                >()
                                .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Inituser {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<inituser/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct InituserBuilder {
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern3>,
    >,
}
impl InituserBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern3,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern3,
                >,
            >>::Error,
        >,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Inituser`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Inituser> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("inituser", "value"))?,
        );
        Ok(Inituser { value })
    }
}

--- os_exe/type.rs ---
//!`type` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
use crate::archnames::Archnames;
///`<type/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Type {
    pub arch: Option<Archnames>,
}
impl ToXml for Type {
    type Builder = TypeBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("type");
        {
            let elem = &self.arch;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"arch"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        let empty = { true && (false) };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            writer.write_event(Event::Text(BytesText::new("exe")))?;
            writer.write_event(Event::End(BytesEnd::new("type")))?;
        }
        Ok(())
    }
}
impl Type {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("arch") {
            builder.arch(Some(Archnames::from_str(val)?))?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                "exe" => {
                    builder.exe()?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Type {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<type/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBuilder {
    pub arch: Option<Archnames>,
    pub exe: Option<()>,
}
impl TypeBuilder {
    pub fn arch<T>(&mut self, arch: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Archnames>,
        Error: From<<T as TryInto<Archnames>>::Error>,
    {
        self.arch = if let Some(arch) = arch { Some(arch.try_into()?) } else { None };
        Ok(self)
    }
    pub fn exe(&mut self) -> Result<&mut Self> {
        self.exe = Some(());
        Ok(self)
    }
    /**
            Attempt to build [`Type`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Type> {
        let arch = Clone::clone(&self.arch);
        let exe = Clone::clone(
            self.exe.as_ref().ok_or(Error::BuilderMissingField("type", "exe"))?,
        );
        Ok(Type { arch })
    }
}

--- os_exe.rs ---
//!`os` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod init;
use init::Init;
pub mod initarg;
use initarg::Initarg;
pub mod initdir;
use initdir::Initdir;
pub mod initenv;
use initenv::Initenv;
pub mod initgroup;
use initgroup::Initgroup;
pub mod inituser;
use inituser::Inituser;
pub mod r#type;
use r#type::Type;
///`<os/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OsExe {
    pub r_type: Type,
    pub init: Option<Init>,
    pub initargs: Vec<Initarg>,
    pub initenvs: Vec<Initenv>,
    pub initdir: Option<Initdir>,
    pub inituser: Option<Inituser>,
    pub initgroup: Option<Initgroup>,
}
impl ToXml for OsExe {
    type Builder = OsExeBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("os");
        let empty = {
            true
                && ({
                    let elem = &self.r_type;
                    false
                })
                && ({
                    let elem = &self.init;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.initargs;
                    elem.iter().all(|elem| false)
                })
                && ({
                    let elem = &self.initenvs;
                    elem.iter().all(|elem| false)
                })
                && ({
                    let elem = &self.initdir;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.inituser;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.initgroup;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.r_type;
                elem.to_xml(writer)?;
            }
            {
                let elem = &self.init;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.initargs;
                for elem in elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.initenvs;
                for elem in elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.initdir;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.inituser;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.initgroup;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            writer.write_event(Event::End(BytesEnd::new("os")))?;
        }
        Ok(())
    }
}
impl OsExe {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                "type" if Type::from_xml(&child).is_ok() => {
                    builder.r_type(Type::from_xml(&child)?)?;
                }
                "init" if Init::from_xml(&child).is_ok() => {
                    builder.init(Some(Init::from_xml(&child)?))?;
                }
                "initarg" if Initarg::from_xml(&child).is_ok() => {
                    builder.initarg(Initarg::from_xml(&child)?)?;
                }
                "initenv" if Initenv::from_xml(&child).is_ok() => {
                    builder.initenv(Initenv::from_xml(&child)?)?;
                }
                "initdir" if Initdir::from_xml(&child).is_ok() => {
                    builder.initdir(Some(Initdir::from_xml(&child)?))?;
                }
                "inituser" if Inituser::from_xml(&child).is_ok() => {
                    builder.inituser(Some(Inituser::from_xml(&child)?))?;
                }
                "initgroup" if Initgroup::from_xml(&child).is_ok() => {
                    builder.initgroup(Some(Initgroup::from_xml(&child)?))?;
                }
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for OsExe {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<os/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct OsExeBuilder {
    pub r_type: Option<Type>,
    pub init: Option<Init>,
    pub initargs: Vec<Initarg>,
    pub initenvs: Vec<Initenv>,
    pub initdir: Option<Initdir>,
    pub inituser: Option<Inituser>,
    pub initgroup: Option<Initgroup>,
}
impl OsExeBuilder {
    pub fn r_type<T>(&mut self, r_type: T) -> Result<&mut Self>
    where
        T: TryInto<Type>,
        Error: From<<T as TryInto<Type>>::Error>,
    {
        self.r_type = Some(r_type.try_into()?);
        Ok(self)
    }
    pub fn init<T>(&mut self, init: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Init>,
        Error: From<<T as TryInto<Init>>::Error>,
    {
        self.init = if let Some(init) = init { Some(init.try_into()?) } else { None };
        Ok(self)
    }
    pub fn initarg<T>(&mut self, initarg: T) -> Result<&mut Self>
    where
        T: TryInto<Initarg>,
        Error: From<<T as TryInto<Initarg>>::Error>,
    {
        self.initargs.push(initarg.try_into()?);
        Ok(self)
    }
    pub fn initenv<T>(&mut self, initenv: T) -> Result<&mut Self>
    where
        T: TryInto<Initenv>,
        Error: From<<T as TryInto<Initenv>>::Error>,
    {
        self.initenvs.push(initenv.try_into()?);
        Ok(self)
    }
    pub fn initdir<T>(&mut self, initdir: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Initdir>,
        Error: From<<T as TryInto<Initdir>>::Error>,
    {
        self.initdir = if let Some(initdir) = initdir {
            Some(initdir.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn inituser<T>(&mut self, inituser: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Inituser>,
        Error: From<<T as TryInto<Inituser>>::Error>,
    {
        self.inituser = if let Some(inituser) = inituser {
            Some(inituser.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn initgroup<T>(&mut self, initgroup: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Initgroup>,
        Error: From<<T as TryInto<Initgroup>>::Error>,
    {
        self.initgroup = if let Some(initgroup) = initgroup {
            Some(initgroup.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    /**
            Attempt to build [`OsExe`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<OsExe> {
        let r_type = Clone::clone(
            self.r_type.as_ref().ok_or(Error::BuilderMissingField("os", "r_type"))?,
        );
        let init = Clone::clone(&self.init);
        let initargs = Clone::clone(&self.initargs);
        let initenvs = Clone::clone(&self.initenvs);
        let initdir = Clone::clone(&self.initdir);
        let inituser = Clone::clone(&self.inituser);
        let initgroup = Clone::clone(&self.initgroup);
        Ok(OsExe {
            r_type,
            init,
            initargs,
            initenvs,
            initdir,
            inituser,
            initgroup,
        })
    }
}

--- os_hvm/bootmenu.rs ---
//!`bootmenu` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
use crate::vir_yes_no::VirYesNo;
///`<bootmenu/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Bootmenu {
    pub enable: VirYesNo,
    pub timeout: Option<u16>,
}
impl ToXml for Bootmenu {
    type Builder = BootmenuBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("bootmenu");
        {
            let elem = &self.enable;
            xml_start
                .push_attribute((
                    &b"enable"[..],
                    quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                ));
        }
        {
            let elem = &self.timeout;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"timeout"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        let empty = { true };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            writer.write_event(Event::End(BytesEnd::new("bootmenu")))?;
        }
        Ok(())
    }
}
impl Bootmenu {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("enable") {
            builder.enable(VirYesNo::from_str(val)?)?;
        }
        if let Some(val) = node.attribute("timeout") {
            builder
                .timeout(
                    Some(
                        val
                            .parse::<u16>()
                            .map_err(|e| Error::ParseError("timeout", Box::new(e)))?,
                    ),
                )?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Bootmenu {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<bootmenu/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BootmenuBuilder {
    pub enable: Option<VirYesNo>,
    pub timeout: Option<u16>,
}
impl BootmenuBuilder {
    pub fn enable<T>(&mut self, enable: T) -> Result<&mut Self>
    where
        T: TryInto<VirYesNo>,
        Error: From<<T as TryInto<VirYesNo>>::Error>,
    {
        self.enable = Some(enable.try_into()?);
        Ok(self)
    }
    pub fn timeout<T>(&mut self, timeout: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<u16>,
        Error: From<<T as TryInto<u16>>::Error>,
    {
        self.timeout = if let Some(timeout) = timeout {
            Some(timeout.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    /**
            Attempt to build [`Bootmenu`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Bootmenu> {
        let enable = Clone::clone(
            self.enable.as_ref().ok_or(Error::BuilderMissingField("bootmenu", "enable"))?,
        );
        let timeout = Clone::clone(&self.timeout);
        Ok(Bootmenu { enable, timeout })
    }
}

--- os_hvm/firmware/feature/name_choice.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum NameChoice {
    EnrolledKeys,
    SecureBoot,
}
impl ToXml for NameChoice {
    type Builder = NameChoiceBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::EnrolledKeys => {
                writer.write_event(Event::Text(BytesText::new("enrolled-keys")))?;
            }
            Self::SecureBoot => {
                writer.write_event(Event::Text(BytesText::new("secure-boot")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for NameChoice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl NameChoice {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<NameChoice> {
        let mut builder = NameChoice::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "enrolled-keys" => {
                                builder.enrolled_keys()?;
                            }
                            "secure-boot" => {
                                builder.secure_boot()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::EnrolledKeys => {}
            Self::SecureBoot => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for NameChoice {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "enrolled-keys" => {
                builder.enrolled_keys()?;
            }
            "secure-boot" => {
                builder.secure_boot()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameChoiceBuilder {
    enrolled_keys: Option<()>,
    secure_boot: Option<()>,
}
impl NameChoiceBuilder {
    pub fn enrolled_keys(&mut self) -> Result<&mut Self> {
        self.enrolled_keys = Some(());
        Ok(self)
    }
    pub fn secure_boot(&mut self) -> Result<&mut Self> {
        self.secure_boot = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<NameChoice> {
        if self.enrolled_keys.is_some() {
            return Ok(NameChoice::EnrolledKeys);
        }
        if self.secure_boot.is_some() {
            return Ok(NameChoice::SecureBoot);
        }
        Err(Error::BuilderVariant("NameChoice"))
    }
}

--- os_hvm/firmware/feature.rs ---
//!`feature` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod name_choice;
use name_choice::NameChoice;
use crate::vir_yes_no::VirYesNo;
///`<feature/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Feature {
    pub enabled: VirYesNo,
    pub name: NameChoice,
}
impl ToXml for Feature {
    type Builder = FeatureBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("feature");
        {
            let elem = &self.enabled;
            xml_start
                .push_attribute((
                    &b"enabled"[..],
                    quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                ));
        }
        {
            let elem = &self.name;
            xml_start
                .push_attribute((
                    &b"name"[..],
                    quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                ));
        }
        let empty = { true };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            writer.write_event(Event::End(BytesEnd::new("feature")))?;
        }
        Ok(())
    }
}
impl Feature {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("enabled") {
            builder.enabled(VirYesNo::from_str(val)?)?;
        }
        if let Some(val) = node.attribute("name") {
            builder.name(NameChoice::from_str(val)?)?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Feature {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<feature/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct FeatureBuilder {
    pub enabled: Option<VirYesNo>,
    pub name: Option<NameChoice>,
}
impl FeatureBuilder {
    pub fn enabled<T>(&mut self, enabled: T) -> Result<&mut Self>
    where
        T: TryInto<VirYesNo>,
        Error: From<<T as TryInto<VirYesNo>>::Error>,
    {
        self.enabled = Some(enabled.try_into()?);
        Ok(self)
    }
    pub fn name<T>(&mut self, name: T) -> Result<&mut Self>
    where
        T: TryInto<NameChoice>,
        Error: From<<T as TryInto<NameChoice>>::Error>,
    {
        self.name = Some(name.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Feature`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Feature> {
        let enabled = Clone::clone(
            self
                .enabled
                .as_ref()
                .ok_or(Error::BuilderMissingField("feature", "enabled"))?,
        );
        let name = Clone::clone(
            self.name.as_ref().ok_or(Error::BuilderMissingField("feature", "name"))?,
        );
        Ok(Feature { enabled, name })
    }
}

--- os_hvm/firmware.rs ---
//!`firmware` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod feature;
use feature::Feature;
///`<firmware/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Firmware {
    pub features: Vec<Feature>,
}
impl ToXml for Firmware {
    type Builder = FirmwareBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("firmware");
        let empty = {
            true
                && ({
                    let elem = &self.features;
                    elem.iter().all(|elem| false)
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.features;
                for elem in elem {
                    elem.to_xml(writer)?;
                }
            }
            writer.write_event(Event::End(BytesEnd::new("firmware")))?;
        }
        Ok(())
    }
}
impl Firmware {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                "feature" if Feature::from_xml(&child).is_ok() => {
                    builder.feature(Feature::from_xml(&child)?)?;
                }
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Firmware {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<firmware/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct FirmwareBuilder {
    pub features: Vec<Feature>,
}
impl FirmwareBuilder {
    pub fn feature<T>(&mut self, feature: T) -> Result<&mut Self>
    where
        T: TryInto<Feature>,
        Error: From<<T as TryInto<Feature>>::Error>,
    {
        self.features.push(feature.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Firmware`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Firmware> {
        let features = if self.features.is_empty() {
            return Err(Error::BuilderMissingField("firmware", "features"));
        } else {
            Clone::clone(&self.features)
        };
        Ok(Firmware { features })
    }
}

--- os_hvm/firmware_choice.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FirmwareChoice {
    Bios,
    Efi,
}
impl ToXml for FirmwareChoice {
    type Builder = FirmwareChoiceBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Bios => {
                writer.write_event(Event::Text(BytesText::new("bios")))?;
            }
            Self::Efi => {
                writer.write_event(Event::Text(BytesText::new("efi")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for FirmwareChoice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl FirmwareChoice {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<FirmwareChoice> {
        let mut builder = FirmwareChoice::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "bios" => {
                                builder.bios()?;
                            }
                            "efi" => {
                                builder.efi()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Bios => {}
            Self::Efi => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for FirmwareChoice {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "bios" => {
                builder.bios()?;
            }
            "efi" => {
                builder.efi()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct FirmwareChoiceBuilder {
    bios: Option<()>,
    efi: Option<()>,
}
impl FirmwareChoiceBuilder {
    pub fn bios(&mut self) -> Result<&mut Self> {
        self.bios = Some(());
        Ok(self)
    }
    pub fn efi(&mut self) -> Result<&mut Self> {
        self.efi = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<FirmwareChoice> {
        if self.bios.is_some() {
            return Ok(FirmwareChoice::Bios);
        }
        if self.efi.is_some() {
            return Ok(FirmwareChoice::Efi);
        }
        Err(Error::BuilderVariant("FirmwareChoice"))
    }
}

--- os_hvm/loader/type_choice.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeChoice {
    Rom,
    Pflash,
}
impl ToXml for TypeChoice {
    type Builder = TypeChoiceBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Rom => {
                writer.write_event(Event::Text(BytesText::new("rom")))?;
            }
            Self::Pflash => {
                writer.write_event(Event::Text(BytesText::new("pflash")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for TypeChoice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl TypeChoice {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<TypeChoice> {
        let mut builder = TypeChoice::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "pflash" => {
                                builder.pflash()?;
                            }
                            "rom" => {
                                builder.rom()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Rom => {}
            Self::Pflash => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for TypeChoice {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "pflash" => {
                builder.pflash()?;
            }
            "rom" => {
                builder.rom()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeChoiceBuilder {
    rom: Option<()>,
    pflash: Option<()>,
}
impl TypeChoiceBuilder {
    pub fn rom(&mut self) -> Result<&mut Self> {
        self.rom = Some(());
        Ok(self)
    }
    pub fn pflash(&mut self) -> Result<&mut Self> {
        self.pflash = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<TypeChoice> {
        if self.rom.is_some() {
            return Ok(TypeChoice::Rom);
        }
        if self.pflash.is_some() {
            return Ok(TypeChoice::Pflash);
        }
        Err(Error::BuilderVariant("TypeChoice"))
    }
}

--- os_hvm/loader.rs ---
//!`loader` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod type_choice;
use type_choice::TypeChoice;
use crate::pflash_format_types::PflashFormatTypes;
use crate::vir_yes_no::VirYesNo;
///`<loader/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Loader {
    pub readonly: Option<VirYesNo>,
    pub secure: Option<VirYesNo>,
    pub r#type: Option<TypeChoice>,
    pub stateless: Option<VirYesNo>,
    pub format: Option<PflashFormatTypes>,
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl ToXml for Loader {
    type Builder = LoaderBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("loader");
        {
            let elem = &self.readonly;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"readonly"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        {
            let elem = &self.secure;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"secure"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        {
            let elem = &self.r#type;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"type"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        {
            let elem = &self.stateless;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"stateless"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        {
            let elem = &self.format;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"format"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                if let Some(elem) = elem {
                    writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
                }
            }
            writer.write_event(Event::End(BytesEnd::new("loader")))?;
        }
        Ok(())
    }
}
impl Loader {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("readonly") {
            builder.readonly(Some(VirYesNo::from_str(val)?))?;
        }
        if let Some(val) = node.attribute("secure") {
            builder.secure(Some(VirYesNo::from_str(val)?))?;
        }
        if let Some(val) = node.attribute("type") {
            builder.r#type(Some(TypeChoice::from_str(val)?))?;
        }
        if let Some(val) = node.attribute("stateless") {
            builder.stateless(Some(VirYesNo::from_str(val)?))?;
        }
        if let Some(val) = node.attribute("format") {
            builder.format(Some(PflashFormatTypes::from_str(val)?))?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern0,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            Some(
                                val
                                    .parse::<
                                        crate::ConstrainedString<
                                            0usize,
                                            18446744073709551615usize,
                                            crate::RegexPattern0,
                                        >,
                                    >()
                                    .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                            ),
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Loader {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<loader/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoaderBuilder {
    pub readonly: Option<VirYesNo>,
    pub secure: Option<VirYesNo>,
    pub r#type: Option<TypeChoice>,
    pub stateless: Option<VirYesNo>,
    pub format: Option<PflashFormatTypes>,
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl LoaderBuilder {
    pub fn readonly<T>(&mut self, readonly: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<VirYesNo>,
        Error: From<<T as TryInto<VirYesNo>>::Error>,
    {
        self.readonly = if let Some(readonly) = readonly {
            Some(readonly.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn secure<T>(&mut self, secure: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<VirYesNo>,
        Error: From<<T as TryInto<VirYesNo>>::Error>,
    {
        self.secure = if let Some(secure) = secure {
            Some(secure.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn r#type<T>(&mut self, r#type: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<TypeChoice>,
        Error: From<<T as TryInto<TypeChoice>>::Error>,
    {
        self.r#type = if let Some(r#type) = r#type {
            Some(r#type.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn stateless<T>(&mut self, stateless: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<VirYesNo>,
        Error: From<<T as TryInto<VirYesNo>>::Error>,
    {
        self.stateless = if let Some(stateless) = stateless {
            Some(stateless.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn format<T>(&mut self, format: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<PflashFormatTypes>,
        Error: From<<T as TryInto<PflashFormatTypes>>::Error>,
    {
        self.format = if let Some(format) = format {
            Some(format.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn value<T>(&mut self, value: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.value = if let Some(value) = value {
            Some(value.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    /**
            Attempt to build [`Loader`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Loader> {
        let readonly = Clone::clone(&self.readonly);
        let secure = Clone::clone(&self.secure);
        let r#type = Clone::clone(&self.r#type);
        let stateless = Clone::clone(&self.stateless);
        let format = Clone::clone(&self.format);
        let value = Clone::clone(&self.value);
        Ok(Loader {
            readonly,
            secure,
            r#type,
            stateless,
            format,
            value,
        })
    }
}

--- os_hvm/nvram.rs ---
//!`nvram` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
use crate::pflash_format_types::PflashFormatTypes;
///`<nvram/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Nvram {
    pub template: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
    pub template_format: Option<PflashFormatTypes>,
    pub format: Option<PflashFormatTypes>,
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl ToXml for Nvram {
    type Builder = NvramBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("nvram");
        {
            let elem = &self.template;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"template"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        {
            let elem = &self.template_format;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"templateFormat"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        {
            let elem = &self.format;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"format"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                if let Some(elem) = elem {
                    writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
                }
            }
            writer.write_event(Event::End(BytesEnd::new("nvram")))?;
        }
        Ok(())
    }
}
impl Nvram {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("template") {
            builder
                .template(
                    Some(
                        val
                            .parse::<
                                crate::ConstrainedString<
                                    0usize,
                                    18446744073709551615usize,
                                    crate::RegexPattern0,
                                >,
                            >()
                            .map_err(|e| Error::ParseError("template", Box::new(e)))?,
                    ),
                )?;
        }
        if let Some(val) = node.attribute("templateFormat") {
            builder.template_format(Some(PflashFormatTypes::from_str(val)?))?;
        }
        if let Some(val) = node.attribute("format") {
            builder.format(Some(PflashFormatTypes::from_str(val)?))?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern0,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            Some(
                                val
                                    .parse::<
                                        crate::ConstrainedString<
                                            0usize,
                                            18446744073709551615usize,
                                            crate::RegexPattern0,
                                        >,
                                    >()
                                    .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                            ),
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Nvram {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<nvram/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct NvramBuilder {
    pub template: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
    pub template_format: Option<PflashFormatTypes>,
    pub format: Option<PflashFormatTypes>,
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl NvramBuilder {
    pub fn template<T>(&mut self, template: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.template = if let Some(template) = template {
            Some(template.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn template_format<T>(&mut self, template_format: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<PflashFormatTypes>,
        Error: From<<T as TryInto<PflashFormatTypes>>::Error>,
    {
        self.template_format = if let Some(template_format) = template_format {
            Some(template_format.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn format<T>(&mut self, format: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<PflashFormatTypes>,
        Error: From<<T as TryInto<PflashFormatTypes>>::Error>,
    {
        self.format = if let Some(format) = format {
            Some(format.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn value<T>(&mut self, value: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.value = if let Some(value) = value {
            Some(value.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    /**
            Attempt to build [`Nvram`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Nvram> {
        let template = Clone::clone(&self.template);
        let template_format = Clone::clone(&self.template_format);
        let format = Clone::clone(&self.format);
        let value = Clone::clone(&self.value);
        Ok(Nvram {
            template,
            template_format,
            format,
            value,
        })
    }
}

--- os_hvm.rs ---
//!`os` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod bootmenu;
use bootmenu::Bootmenu;
pub mod firmware;
use firmware::Firmware;
pub mod firmware_choice;
use firmware_choice::FirmwareChoice;
pub mod loader;
use loader::Loader;
pub mod nvram;
use nvram::Nvram;
use crate::acpi::Acpi;
use crate::bios::Bios;
use crate::boot::Boot;
use crate::cmdline::Cmdline;
use crate::dtb::Dtb;
use crate::initrd::Initrd;
use crate::kernel::Kernel;
use crate::r#type::Type;
use crate::root::Root;
use crate::shim::Shim;
use crate::smbios::Smbios;
///`<os/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OsHvm {
    pub firmware_attr: Option<FirmwareChoice>,
    pub r_type: Type,
    pub firmware: Option<Firmware>,
    pub loader: Option<Loader>,
    pub nvram: Option<Nvram>,
    pub kernel: Option<Kernel>,
    pub initrd: Option<Initrd>,
    pub root: Option<Root>,
    pub cmdline: Option<Cmdline>,
    pub shim: Option<Shim>,
    pub dtb: Option<Dtb>,
    pub boots: Vec<Boot>,
    pub bootmenu: Option<Bootmenu>,
    pub smbios: Option<Smbios>,
    pub bios: Option<Bios>,
    pub acpi: Option<Acpi>,
}
impl ToXml for OsHvm {
    type Builder = OsHvmBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("os");
        {
            let elem = &self.firmware_attr;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"firmware"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        let empty = {
            true
                && ({
                    let elem = &self.r_type;
                    false
                })
                && ({
                    let elem = &self.firmware;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.loader;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.nvram;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.kernel;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.initrd;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.root;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.cmdline;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.shim;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.dtb;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.boots;
                    elem.iter().all(|elem| false)
                })
                && ({
                    let elem = &self.bootmenu;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.smbios;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.bios;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.acpi;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.r_type;
                elem.to_xml(writer)?;
            }
            {
                let elem = &self.firmware;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.loader;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.nvram;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.kernel;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.initrd;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.root;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.cmdline;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.shim;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.dtb;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.boots;
                for elem in elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.bootmenu;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.smbios;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.bios;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.acpi;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            writer.write_event(Event::End(BytesEnd::new("os")))?;
        }
        Ok(())
    }
}
impl OsHvm {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("firmware") {
            builder.firmware_attr(Some(FirmwareChoice::from_str(val)?))?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                "type" if Type::from_xml(&child).is_ok() => {
                    builder.r_type(Type::from_xml(&child)?)?;
                }
                "firmware" if Firmware::from_xml(&child).is_ok() => {
                    builder.firmware(Some(Firmware::from_xml(&child)?))?;
                }
                "loader" if Loader::from_xml(&child).is_ok() => {
                    builder.loader(Some(Loader::from_xml(&child)?))?;
                }
                "nvram" if Nvram::from_xml(&child).is_ok() => {
                    builder.nvram(Some(Nvram::from_xml(&child)?))?;
                }
                "kernel" if Kernel::from_xml(&child).is_ok() => {
                    builder.kernel(Some(Kernel::from_xml(&child)?))?;
                }
                "initrd" if Initrd::from_xml(&child).is_ok() => {
                    builder.initrd(Some(Initrd::from_xml(&child)?))?;
                }
                "root" if Root::from_xml(&child).is_ok() => {
                    builder.root(Some(Root::from_xml(&child)?))?;
                }
                "cmdline" if Cmdline::from_xml(&child).is_ok() => {
                    builder.cmdline(Some(Cmdline::from_xml(&child)?))?;
                }
                "shim" if Shim::from_xml(&child).is_ok() => {
                    builder.shim(Some(Shim::from_xml(&child)?))?;
                }
                "dtb" if Dtb::from_xml(&child).is_ok() => {
                    builder.dtb(Some(Dtb::from_xml(&child)?))?;
                }
                "boot" if Boot::from_xml(&child).is_ok() => {
                    builder.boot(Boot::from_xml(&child)?)?;
                }
                "bootmenu" if Bootmenu::from_xml(&child).is_ok() => {
                    builder.bootmenu(Some(Bootmenu::from_xml(&child)?))?;
                }
                "smbios" if Smbios::from_xml(&child).is_ok() => {
                    builder.smbios(Some(Smbios::from_xml(&child)?))?;
                }
                "bios" if Bios::from_xml(&child).is_ok() => {
                    builder.bios(Some(Bios::from_xml(&child)?))?;
                }
                "acpi" if Acpi::from_xml(&child).is_ok() => {
                    builder.acpi(Some(Acpi::from_xml(&child)?))?;
                }
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for OsHvm {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<os/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct OsHvmBuilder {
    pub firmware_attr: Option<FirmwareChoice>,
    pub r_type: Option<Type>,
    pub firmware: Option<Firmware>,
    pub loader: Option<Loader>,
    pub nvram: Option<Nvram>,
    pub kernel: Option<Kernel>,
    pub initrd: Option<Initrd>,
    pub root: Option<Root>,
    pub cmdline: Option<Cmdline>,
    pub shim: Option<Shim>,
    pub dtb: Option<Dtb>,
    pub boots: Vec<Boot>,
    pub bootmenu: Option<Bootmenu>,
    pub smbios: Option<Smbios>,
    pub bios: Option<Bios>,
    pub acpi: Option<Acpi>,
}
impl OsHvmBuilder {
    pub fn firmware_attr<T>(&mut self, firmware_attr: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<FirmwareChoice>,
        Error: From<<T as TryInto<FirmwareChoice>>::Error>,
    {
        self.firmware_attr = if let Some(firmware_attr) = firmware_attr {
            Some(firmware_attr.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn r_type<T>(&mut self, r_type: T) -> Result<&mut Self>
    where
        T: TryInto<Type>,
        Error: From<<T as TryInto<Type>>::Error>,
    {
        self.r_type = Some(r_type.try_into()?);
        Ok(self)
    }
    pub fn firmware<T>(&mut self, firmware: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Firmware>,
        Error: From<<T as TryInto<Firmware>>::Error>,
    {
        self.firmware = if let Some(firmware) = firmware {
            Some(firmware.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn loader<T>(&mut self, loader: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Loader>,
        Error: From<<T as TryInto<Loader>>::Error>,
    {
        self.loader = if let Some(loader) = loader {
            Some(loader.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn nvram<T>(&mut self, nvram: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Nvram>,
        Error: From<<T as TryInto<Nvram>>::Error>,
    {
        self.nvram = if let Some(nvram) = nvram {
            Some(nvram.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn kernel<T>(&mut self, kernel: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Kernel>,
        Error: From<<T as TryInto<Kernel>>::Error>,
    {
        self.kernel = if let Some(kernel) = kernel {
            Some(kernel.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn initrd<T>(&mut self, initrd: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Initrd>,
        Error: From<<T as TryInto<Initrd>>::Error>,
    {
        self.initrd = if let Some(initrd) = initrd {
            Some(initrd.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn root<T>(&mut self, root: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Root>,
        Error: From<<T as TryInto<Root>>::Error>,
    {
        self.root = if let Some(root) = root { Some(root.try_into()?) } else { None };
        Ok(self)
    }
    pub fn cmdline<T>(&mut self, cmdline: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Cmdline>,
        Error: From<<T as TryInto<Cmdline>>::Error>,
    {
        self.cmdline = if let Some(cmdline) = cmdline {
            Some(cmdline.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn shim<T>(&mut self, shim: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Shim>,
        Error: From<<T as TryInto<Shim>>::Error>,
    {
        self.shim = if let Some(shim) = shim { Some(shim.try_into()?) } else { None };
        Ok(self)
    }
    pub fn dtb<T>(&mut self, dtb: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Dtb>,
        Error: From<<T as TryInto<Dtb>>::Error>,
    {
        self.dtb = if let Some(dtb) = dtb { Some(dtb.try_into()?) } else { None };
        Ok(self)
    }
    pub fn boot<T>(&mut self, boot: T) -> Result<&mut Self>
    where
        T: TryInto<Boot>,
        Error: From<<T as TryInto<Boot>>::Error>,
    {
        self.boots.push(boot.try_into()?);
        Ok(self)
    }
    pub fn bootmenu<T>(&mut self, bootmenu: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Bootmenu>,
        Error: From<<T as TryInto<Bootmenu>>::Error>,
    {
        self.bootmenu = if let Some(bootmenu) = bootmenu {
            Some(bootmenu.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn smbios<T>(&mut self, smbios: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Smbios>,
        Error: From<<T as TryInto<Smbios>>::Error>,
    {
        self.smbios = if let Some(smbios) = smbios {
            Some(smbios.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn bios<T>(&mut self, bios: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Bios>,
        Error: From<<T as TryInto<Bios>>::Error>,
    {
        self.bios = if let Some(bios) = bios { Some(bios.try_into()?) } else { None };
        Ok(self)
    }
    pub fn acpi<T>(&mut self, acpi: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Acpi>,
        Error: From<<T as TryInto<Acpi>>::Error>,
    {
        self.acpi = if let Some(acpi) = acpi { Some(acpi.try_into()?) } else { None };
        Ok(self)
    }
    /**
            Attempt to build [`OsHvm`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<OsHvm> {
        let firmware_attr = Clone::clone(&self.firmware_attr);
        let r_type = Clone::clone(
            self.r_type.as_ref().ok_or(Error::BuilderMissingField("os", "r_type"))?,
        );
        let firmware = Clone::clone(&self.firmware);
        let loader = Clone::clone(&self.loader);
        let nvram = Clone::clone(&self.nvram);
        let kernel = Clone::clone(&self.kernel);
        let initrd = Clone::clone(&self.initrd);
        let root = Clone::clone(&self.root);
        let cmdline = Clone::clone(&self.cmdline);
        let shim = Clone::clone(&self.shim);
        let dtb = Clone::clone(&self.dtb);
        let boots = Clone::clone(&self.boots);
        let bootmenu = Clone::clone(&self.bootmenu);
        let smbios = Clone::clone(&self.smbios);
        let bios = Clone::clone(&self.bios);
        let acpi = Clone::clone(&self.acpi);
        Ok(OsHvm {
            firmware_attr,
            r_type,
            firmware,
            loader,
            nvram,
            kernel,
            initrd,
            root,
            cmdline,
            shim,
            dtb,
            boots,
            bootmenu,
            smbios,
            bios,
            acpi,
        })
    }
}

--- osxen/os.rs ---
//!`os` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
use crate::cmdline::Cmdline;
use crate::dtb::Dtb;
use crate::initrd::Initrd;
use crate::kernel::Kernel;
use crate::r#type::Type;
use crate::root::Root;
use crate::shim::Shim;
///`<os/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Os {
    pub r_type: Type,
    pub kernel: Option<Kernel>,
    pub initrd: Option<Initrd>,
    pub root: Option<Root>,
    pub cmdline: Option<Cmdline>,
    pub shim: Option<Shim>,
    pub dtb: Option<Dtb>,
}
impl ToXml for Os {
    type Builder = OsBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("os");
        let empty = {
            true
                && ({
                    let elem = &self.r_type;
                    false
                })
                && ({
                    let elem = &self.kernel;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.initrd;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.root;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.cmdline;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.shim;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
                && ({
                    let elem = &self.dtb;
                    elem.as_ref().map(|elem| false).unwrap_or(true)
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.r_type;
                elem.to_xml(writer)?;
            }
            {
                let elem = &self.kernel;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.initrd;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.root;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.cmdline;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.shim;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.dtb;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            writer.write_event(Event::End(BytesEnd::new("os")))?;
        }
        Ok(())
    }
}
impl Os {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                "type" if Type::from_xml(&child).is_ok() => {
                    builder.r_type(Type::from_xml(&child)?)?;
                }
                "kernel" if Kernel::from_xml(&child).is_ok() => {
                    builder.kernel(Some(Kernel::from_xml(&child)?))?;
                }
                "initrd" if Initrd::from_xml(&child).is_ok() => {
                    builder.initrd(Some(Initrd::from_xml(&child)?))?;
                }
                "root" if Root::from_xml(&child).is_ok() => {
                    builder.root(Some(Root::from_xml(&child)?))?;
                }
                "cmdline" if Cmdline::from_xml(&child).is_ok() => {
                    builder.cmdline(Some(Cmdline::from_xml(&child)?))?;
                }
                "shim" if Shim::from_xml(&child).is_ok() => {
                    builder.shim(Some(Shim::from_xml(&child)?))?;
                }
                "dtb" if Dtb::from_xml(&child).is_ok() => {
                    builder.dtb(Some(Dtb::from_xml(&child)?))?;
                }
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Os {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<os/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct OsBuilder {
    pub r_type: Option<Type>,
    pub kernel: Option<Kernel>,
    pub initrd: Option<Initrd>,
    pub root: Option<Root>,
    pub cmdline: Option<Cmdline>,
    pub shim: Option<Shim>,
    pub dtb: Option<Dtb>,
}
impl OsBuilder {
    pub fn r_type<T>(&mut self, r_type: T) -> Result<&mut Self>
    where
        T: TryInto<Type>,
        Error: From<<T as TryInto<Type>>::Error>,
    {
        self.r_type = Some(r_type.try_into()?);
        Ok(self)
    }
    pub fn kernel<T>(&mut self, kernel: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Kernel>,
        Error: From<<T as TryInto<Kernel>>::Error>,
    {
        self.kernel = if let Some(kernel) = kernel {
            Some(kernel.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn initrd<T>(&mut self, initrd: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Initrd>,
        Error: From<<T as TryInto<Initrd>>::Error>,
    {
        self.initrd = if let Some(initrd) = initrd {
            Some(initrd.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn root<T>(&mut self, root: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Root>,
        Error: From<<T as TryInto<Root>>::Error>,
    {
        self.root = if let Some(root) = root { Some(root.try_into()?) } else { None };
        Ok(self)
    }
    pub fn cmdline<T>(&mut self, cmdline: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Cmdline>,
        Error: From<<T as TryInto<Cmdline>>::Error>,
    {
        self.cmdline = if let Some(cmdline) = cmdline {
            Some(cmdline.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn shim<T>(&mut self, shim: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Shim>,
        Error: From<<T as TryInto<Shim>>::Error>,
    {
        self.shim = if let Some(shim) = shim { Some(shim.try_into()?) } else { None };
        Ok(self)
    }
    pub fn dtb<T>(&mut self, dtb: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Dtb>,
        Error: From<<T as TryInto<Dtb>>::Error>,
    {
        self.dtb = if let Some(dtb) = dtb { Some(dtb.try_into()?) } else { None };
        Ok(self)
    }
    /**
            Attempt to build [`Os`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Os> {
        let r_type = Clone::clone(
            self.r_type.as_ref().ok_or(Error::BuilderMissingField("os", "r_type"))?,
        );
        let kernel = Clone::clone(&self.kernel);
        let initrd = Clone::clone(&self.initrd);
        let root = Clone::clone(&self.root);
        let cmdline = Clone::clone(&self.cmdline);
        let shim = Clone::clone(&self.shim);
        let dtb = Clone::clone(&self.dtb);
        Ok(Os {
            r_type,
            kernel,
            initrd,
            root,
            cmdline,
            shim,
            dtb,
        })
    }
}

--- osxen.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod os;
use os::Os;
use crate::bootloader::Bootloader;
use crate::bootloader_args::BootloaderArgs;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Osxen {
    #[doc = "/ref[@name='osxen']/choice[1]/interleave[1]"]
    Variant0 {
        bootloader: Option<Bootloader>,
        bootloader_args: Option<BootloaderArgs>,
        os: Os,
    },
    #[doc = "/ref[@name='osxen']/choice[1]/interleave[2]"]
    Variant1 {
        bootloader: Option<Bootloader>,
        bootloader_args: Option<BootloaderArgs>,
        os: Option<Os>,
    },
}
impl ToXml for Osxen {
    type Builder = OsxenBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Variant0 { bootloader, bootloader_args, os } => {
                {
                    let elem = bootloader;
                    if let Some(elem) = elem {
                        elem.to_xml(writer)?;
                    }
                }
                {
                    let elem = bootloader_args;
                    if let Some(elem) = elem {
                        elem.to_xml(writer)?;
                    }
                }
                {
                    let elem = os;
                    elem.to_xml(writer)?;
                }
            }
            Self::Variant1 { bootloader, bootloader_args, os } => {
                {
                    let elem = bootloader;
                    if let Some(elem) = elem {
                        elem.to_xml(writer)?;
                    }
                }
                {
                    let elem = bootloader_args;
                    if let Some(elem) = elem {
                        elem.to_xml(writer)?;
                    }
                }
                {
                    let elem = os;
                    if let Some(elem) = elem {
                        elem.to_xml(writer)?;
                    }
                }
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for Osxen {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl Osxen {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<Osxen> {
        let mut builder = Osxen::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        "bootloader" if Bootloader::from_xml(&child).is_ok() => {
                            builder.bootloader(Some(Bootloader::from_xml(&child)?))?;
                        }
                        "bootloader_args" if BootloaderArgs::from_xml(&child)
                            .is_ok() => {
                            builder
                                .bootloader_args(Some(BootloaderArgs::from_xml(&child)?))?;
                        }
                        "os" if Os::from_xml(&child).is_ok() => {
                            builder.os(Some(Os::from_xml(&child)?))?;
                        }
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Variant0 { bootloader, bootloader_args, os } => {
                let elem = bootloader;
                let elem = bootloader_args;
                let elem = os;
            }
            Self::Variant1 { bootloader, bootloader_args, os } => {
                let elem = bootloader;
                let elem = bootloader_args;
                let elem = os;
            }
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct OsxenBuilder {
    bootloader: Option<Bootloader>,
    bootloader_args: Option<BootloaderArgs>,
    os: Option<Os>,
}
impl OsxenBuilder {
    pub fn bootloader<T>(&mut self, bootloader: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Bootloader>,
        Error: From<<T as TryInto<Bootloader>>::Error>,
    {
        self.bootloader = if let Some(bootloader) = bootloader {
            Some(bootloader.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn bootloader_args<T>(&mut self, bootloader_args: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<BootloaderArgs>,
        Error: From<<T as TryInto<BootloaderArgs>>::Error>,
    {
        self.bootloader_args = if let Some(bootloader_args) = bootloader_args {
            Some(bootloader_args.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn os<T>(&mut self, os: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Os>,
        Error: From<<T as TryInto<Os>>::Error>,
    {
        self.os = if let Some(os) = os { Some(os.try_into()?) } else { None };
        Ok(self)
    }
    pub fn build(&self) -> Result<Osxen> {
        if self.os.is_some() {
            return Ok(Osxen::Variant0 {
                bootloader: Clone::clone(&self.bootloader).into(),
                bootloader_args: Clone::clone(&self.bootloader_args).into(),
                os: Clone::clone(self.os.as_ref().unwrap()).into(),
            });
        }
        return Ok(Osxen::Variant1 {
            bootloader: Clone::clone(&self.bootloader).into(),
            bootloader_args: Clone::clone(&self.bootloader_args).into(),
            os: Clone::clone(&self.os).into(),
        });
    }
}

--- pflash_format_types.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PflashFormatTypes {
    Raw,
    Qcow2,
}
impl ToXml for PflashFormatTypes {
    type Builder = PflashFormatTypesBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Raw => {
                writer.write_event(Event::Text(BytesText::new("raw")))?;
            }
            Self::Qcow2 => {
                writer.write_event(Event::Text(BytesText::new("qcow2")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for PflashFormatTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl PflashFormatTypes {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<PflashFormatTypes> {
        let mut builder = PflashFormatTypes::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "qcow2" => {
                                builder.qcow2()?;
                            }
                            "raw" => {
                                builder.raw()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Raw => {}
            Self::Qcow2 => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for PflashFormatTypes {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "qcow2" => {
                builder.qcow2()?;
            }
            "raw" => {
                builder.raw()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct PflashFormatTypesBuilder {
    raw: Option<()>,
    qcow2: Option<()>,
}
impl PflashFormatTypesBuilder {
    pub fn raw(&mut self) -> Result<&mut Self> {
        self.raw = Some(());
        Ok(self)
    }
    pub fn qcow2(&mut self) -> Result<&mut Self> {
        self.qcow2 = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<PflashFormatTypes> {
        if self.raw.is_some() {
            return Ok(PflashFormatTypes::Raw);
        }
        if self.qcow2.is_some() {
            return Ok(PflashFormatTypes::Qcow2);
        }
        Err(Error::BuilderVariant("PflashFormatTypes"))
    }
}

--- root.rs ---
//!`root` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<root/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Root {
    pub value: crate::ConstrainedString<
        0usize,
        18446744073709551615usize,
        crate::RegexPattern0,
    >,
}
impl ToXml for Root {
    type Builder = RootBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("root");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("root")))?;
        }
        Ok(())
    }
}
impl Root {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                val if val
                    .parse::<
                        crate::ConstrainedString<
                            0usize,
                            18446744073709551615usize,
                            crate::RegexPattern0,
                        >,
                    >()
                    .is_ok() => {
                    builder
                        .value(
                            val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern0,
                                    >,
                                >()
                                .map_err(|e| Error::ParseError("value", Box::new(e)))?,
                        )?;
                }
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Root {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<root/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct RootBuilder {
    pub value: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern0>,
    >,
}
impl RootBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern0,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern0,
                >,
            >>::Error,
        >,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Root`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Root> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("root", "value"))?,
        );
        Ok(Root { value })
    }
}

--- shim.rs ---
//!`shim` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<shim/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Shim {
    pub value: String,
}
impl ToXml for Shim {
    type Builder = ShimBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("shim");
        let empty = {
            true
                && ({
                    let elem = &self.value;
                    false
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.value;
                writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
            }
            writer.write_event(Event::End(BytesEnd::new("shim")))?;
        }
        Ok(())
    }
}
impl Shim {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {
                    builder.value(val)?;
                }
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Shim {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<shim/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct ShimBuilder {
    pub value: Option<String>,
}
impl ShimBuilder {
    pub fn value<T>(&mut self, value: T) -> Result<&mut Self>
    where
        T: TryInto<String>,
        Error: From<<T as TryInto<String>>::Error>,
    {
        self.value = Some(value.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Shim`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Shim> {
        let value = Clone::clone(
            self.value.as_ref().ok_or(Error::BuilderMissingField("shim", "value"))?,
        );
        Ok(Shim { value })
    }
}

--- smbios/mode_choice.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ModeChoice {
    Emulate,
    Host,
    Sysinfo,
}
impl ToXml for ModeChoice {
    type Builder = ModeChoiceBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Emulate => {
                writer.write_event(Event::Text(BytesText::new("emulate")))?;
            }
            Self::Host => {
                writer.write_event(Event::Text(BytesText::new("host")))?;
            }
            Self::Sysinfo => {
                writer.write_event(Event::Text(BytesText::new("sysinfo")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for ModeChoice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl ModeChoice {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<ModeChoice> {
        let mut builder = ModeChoice::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "emulate" => {
                                builder.emulate()?;
                            }
                            "host" => {
                                builder.host()?;
                            }
                            "sysinfo" => {
                                builder.sysinfo()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Emulate => {}
            Self::Host => {}
            Self::Sysinfo => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for ModeChoice {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "emulate" => {
                builder.emulate()?;
            }
            "host" => {
                builder.host()?;
            }
            "sysinfo" => {
                builder.sysinfo()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModeChoiceBuilder {
    emulate: Option<()>,
    host: Option<()>,
    sysinfo: Option<()>,
}
impl ModeChoiceBuilder {
    pub fn emulate(&mut self) -> Result<&mut Self> {
        self.emulate = Some(());
        Ok(self)
    }
    pub fn host(&mut self) -> Result<&mut Self> {
        self.host = Some(());
        Ok(self)
    }
    pub fn sysinfo(&mut self) -> Result<&mut Self> {
        self.sysinfo = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<ModeChoice> {
        if self.emulate.is_some() {
            return Ok(ModeChoice::Emulate);
        }
        if self.host.is_some() {
            return Ok(ModeChoice::Host);
        }
        if self.sysinfo.is_some() {
            return Ok(ModeChoice::Sysinfo);
        }
        Err(Error::BuilderVariant("ModeChoice"))
    }
}

--- smbios.rs ---
//!`smbios` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod mode_choice;
use mode_choice::ModeChoice;
///`<smbios/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Smbios {
    pub mode: ModeChoice,
}
impl ToXml for Smbios {
    type Builder = SmbiosBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("smbios");
        {
            let elem = &self.mode;
            xml_start
                .push_attribute((
                    &b"mode"[..],
                    quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                ));
        }
        let empty = { true };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            writer.write_event(Event::End(BytesEnd::new("smbios")))?;
        }
        Ok(())
    }
}
impl Smbios {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("mode") {
            builder.mode(ModeChoice::from_str(val)?)?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Smbios {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<smbios/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct SmbiosBuilder {
    pub mode: Option<ModeChoice>,
}
impl SmbiosBuilder {
    pub fn mode<T>(&mut self, mode: T) -> Result<&mut Self>
    where
        T: TryInto<ModeChoice>,
        Error: From<<T as TryInto<ModeChoice>>::Error>,
    {
        self.mode = Some(mode.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Smbios`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Smbios> {
        let mode = Clone::clone(
            self.mode.as_ref().ok_or(Error::BuilderMissingField("smbios", "mode"))?,
        );
        Ok(Smbios { mode })
    }
}

--- type/arch_choice.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ArchChoice {
    I686,
    X8664,
    Ia64,
    Aarch64,
    Alpha,
    Armv6l,
    Armv7l,
    Cris,
    Lm32,
    Loongarch64,
    M68k,
    Microblaze,
    Microblazeel,
    Mips,
    Mipsel,
    Mips64,
    Mips64el,
    Openrisc,
    Parisc,
    Parisc64,
    Ppc,
    Ppc64,
    Ppc64le,
    Ppcemb,
    Riscv32,
    Riscv64,
    S390,
    S390x,
    Sh4,
    Sh4eb,
    Sparc,
    Sparc64,
    Unicore32,
    Xtensa,
    Xtensaeb,
}
impl ToXml for ArchChoice {
    type Builder = ArchChoiceBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::I686 => {
                writer.write_event(Event::Text(BytesText::new("i686")))?;
            }
            Self::X8664 => {
                writer.write_event(Event::Text(BytesText::new("x86_64")))?;
            }
            Self::Ia64 => {
                writer.write_event(Event::Text(BytesText::new("ia64")))?;
            }
            Self::Aarch64 => {
                writer.write_event(Event::Text(BytesText::new("aarch64")))?;
            }
            Self::Alpha => {
                writer.write_event(Event::Text(BytesText::new("alpha")))?;
            }
            Self::Armv6l => {
                writer.write_event(Event::Text(BytesText::new("armv6l")))?;
            }
            Self::Armv7l => {
                writer.write_event(Event::Text(BytesText::new("armv7l")))?;
            }
            Self::Cris => {
                writer.write_event(Event::Text(BytesText::new("cris")))?;
            }
            Self::Lm32 => {
                writer.write_event(Event::Text(BytesText::new("lm32")))?;
            }
            Self::Loongarch64 => {
                writer.write_event(Event::Text(BytesText::new("loongarch64")))?;
            }
            Self::M68k => {
                writer.write_event(Event::Text(BytesText::new("m68k")))?;
            }
            Self::Microblaze => {
                writer.write_event(Event::Text(BytesText::new("microblaze")))?;
            }
            Self::Microblazeel => {
                writer.write_event(Event::Text(BytesText::new("microblazeel")))?;
            }
            Self::Mips => {
                writer.write_event(Event::Text(BytesText::new("mips")))?;
            }
            Self::Mipsel => {
                writer.write_event(Event::Text(BytesText::new("mipsel")))?;
            }
            Self::Mips64 => {
                writer.write_event(Event::Text(BytesText::new("mips64")))?;
            }
            Self::Mips64el => {
                writer.write_event(Event::Text(BytesText::new("mips64el")))?;
            }
            Self::Openrisc => {
                writer.write_event(Event::Text(BytesText::new("openrisc")))?;
            }
            Self::Parisc => {
                writer.write_event(Event::Text(BytesText::new("parisc")))?;
            }
            Self::Parisc64 => {
                writer.write_event(Event::Text(BytesText::new("parisc64")))?;
            }
            Self::Ppc => {
                writer.write_event(Event::Text(BytesText::new("ppc")))?;
            }
            Self::Ppc64 => {
                writer.write_event(Event::Text(BytesText::new("ppc64")))?;
            }
            Self::Ppc64le => {
                writer.write_event(Event::Text(BytesText::new("ppc64le")))?;
            }
            Self::Ppcemb => {
                writer.write_event(Event::Text(BytesText::new("ppcemb")))?;
            }
            Self::Riscv32 => {
                writer.write_event(Event::Text(BytesText::new("riscv32")))?;
            }
            Self::Riscv64 => {
                writer.write_event(Event::Text(BytesText::new("riscv64")))?;
            }
            Self::S390 => {
                writer.write_event(Event::Text(BytesText::new("s390")))?;
            }
            Self::S390x => {
                writer.write_event(Event::Text(BytesText::new("s390x")))?;
            }
            Self::Sh4 => {
                writer.write_event(Event::Text(BytesText::new("sh4")))?;
            }
            Self::Sh4eb => {
                writer.write_event(Event::Text(BytesText::new("sh4eb")))?;
            }
            Self::Sparc => {
                writer.write_event(Event::Text(BytesText::new("sparc")))?;
            }
            Self::Sparc64 => {
                writer.write_event(Event::Text(BytesText::new("sparc64")))?;
            }
            Self::Unicore32 => {
                writer.write_event(Event::Text(BytesText::new("unicore32")))?;
            }
            Self::Xtensa => {
                writer.write_event(Event::Text(BytesText::new("xtensa")))?;
            }
            Self::Xtensaeb => {
                writer.write_event(Event::Text(BytesText::new("xtensaeb")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for ArchChoice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl ArchChoice {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<ArchChoice> {
        let mut builder = ArchChoice::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "aarch64" => {
                                builder.aarch64()?;
                            }
                            "alpha" => {
                                builder.alpha()?;
                            }
                            "armv6l" => {
                                builder.armv6l()?;
                            }
                            "armv7l" => {
                                builder.armv7l()?;
                            }
                            "cris" => {
                                builder.cris()?;
                            }
                            "i686" => {
                                builder.i686()?;
                            }
                            "ia64" => {
                                builder.ia64()?;
                            }
                            "lm32" => {
                                builder.lm32()?;
                            }
                            "loongarch64" => {
                                builder.loongarch64()?;
                            }
                            "m68k" => {
                                builder.m68k()?;
                            }
                            "microblaze" => {
                                builder.microblaze()?;
                            }
                            "microblazeel" => {
                                builder.microblazeel()?;
                            }
                            "mips" => {
                                builder.mips()?;
                            }
                            "mips64" => {
                                builder.mips64()?;
                            }
                            "mips64el" => {
                                builder.mips64el()?;
                            }
                            "mipsel" => {
                                builder.mipsel()?;
                            }
                            "openrisc" => {
                                builder.openrisc()?;
                            }
                            "parisc" => {
                                builder.parisc()?;
                            }
                            "parisc64" => {
                                builder.parisc64()?;
                            }
                            "ppc" => {
                                builder.ppc()?;
                            }
                            "ppc64" => {
                                builder.ppc64()?;
                            }
                            "ppc64le" => {
                                builder.ppc64le()?;
                            }
                            "ppcemb" => {
                                builder.ppcemb()?;
                            }
                            "riscv32" => {
                                builder.riscv32()?;
                            }
                            "riscv64" => {
                                builder.riscv64()?;
                            }
                            "s390" => {
                                builder.s390()?;
                            }
                            "s390x" => {
                                builder.s390x()?;
                            }
                            "sh4" => {
                                builder.sh4()?;
                            }
                            "sh4eb" => {
                                builder.sh4eb()?;
                            }
                            "sparc" => {
                                builder.sparc()?;
                            }
                            "sparc64" => {
                                builder.sparc64()?;
                            }
                            "unicore32" => {
                                builder.unicore32()?;
                            }
                            "x86_64" => {
                                builder.x86_64()?;
                            }
                            "xtensa" => {
                                builder.xtensa()?;
                            }
                            "xtensaeb" => {
                                builder.xtensaeb()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::I686 => {}
            Self::X8664 => {}
            Self::Ia64 => {}
            Self::Aarch64 => {}
            Self::Alpha => {}
            Self::Armv6l => {}
            Self::Armv7l => {}
            Self::Cris => {}
            Self::Lm32 => {}
            Self::Loongarch64 => {}
            Self::M68k => {}
            Self::Microblaze => {}
            Self::Microblazeel => {}
            Self::Mips => {}
            Self::Mipsel => {}
            Self::Mips64 => {}
            Self::Mips64el => {}
            Self::Openrisc => {}
            Self::Parisc => {}
            Self::Parisc64 => {}
            Self::Ppc => {}
            Self::Ppc64 => {}
            Self::Ppc64le => {}
            Self::Ppcemb => {}
            Self::Riscv32 => {}
            Self::Riscv64 => {}
            Self::S390 => {}
            Self::S390x => {}
            Self::Sh4 => {}
            Self::Sh4eb => {}
            Self::Sparc => {}
            Self::Sparc64 => {}
            Self::Unicore32 => {}
            Self::Xtensa => {}
            Self::Xtensaeb => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for ArchChoice {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "aarch64" => {
                builder.aarch64()?;
            }
            "alpha" => {
                builder.alpha()?;
            }
            "armv6l" => {
                builder.armv6l()?;
            }
            "armv7l" => {
                builder.armv7l()?;
            }
            "cris" => {
                builder.cris()?;
            }
            "i686" => {
                builder.i686()?;
            }
            "ia64" => {
                builder.ia64()?;
            }
            "lm32" => {
                builder.lm32()?;
            }
            "loongarch64" => {
                builder.loongarch64()?;
            }
            "m68k" => {
                builder.m68k()?;
            }
            "microblaze" => {
                builder.microblaze()?;
            }
            "microblazeel" => {
                builder.microblazeel()?;
            }
            "mips" => {
                builder.mips()?;
            }
            "mips64" => {
                builder.mips64()?;
            }
            "mips64el" => {
                builder.mips64el()?;
            }
            "mipsel" => {
                builder.mipsel()?;
            }
            "openrisc" => {
                builder.openrisc()?;
            }
            "parisc" => {
                builder.parisc()?;
            }
            "parisc64" => {
                builder.parisc64()?;
            }
            "ppc" => {
                builder.ppc()?;
            }
            "ppc64" => {
                builder.ppc64()?;
            }
            "ppc64le" => {
                builder.ppc64le()?;
            }
            "ppcemb" => {
                builder.ppcemb()?;
            }
            "riscv32" => {
                builder.riscv32()?;
            }
            "riscv64" => {
                builder.riscv64()?;
            }
            "s390" => {
                builder.s390()?;
            }
            "s390x" => {
                builder.s390x()?;
            }
            "sh4" => {
                builder.sh4()?;
            }
            "sh4eb" => {
                builder.sh4eb()?;
            }
            "sparc" => {
                builder.sparc()?;
            }
            "sparc64" => {
                builder.sparc64()?;
            }
            "unicore32" => {
                builder.unicore32()?;
            }
            "x86_64" => {
                builder.x86_64()?;
            }
            "xtensa" => {
                builder.xtensa()?;
            }
            "xtensaeb" => {
                builder.xtensaeb()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArchChoiceBuilder {
    i686: Option<()>,
    x86_64: Option<()>,
    ia64: Option<()>,
    aarch64: Option<()>,
    alpha: Option<()>,
    armv6l: Option<()>,
    armv7l: Option<()>,
    cris: Option<()>,
    lm32: Option<()>,
    loongarch64: Option<()>,
    m68k: Option<()>,
    microblaze: Option<()>,
    microblazeel: Option<()>,
    mips: Option<()>,
    mipsel: Option<()>,
    mips64: Option<()>,
    mips64el: Option<()>,
    openrisc: Option<()>,
    parisc: Option<()>,
    parisc64: Option<()>,
    ppc: Option<()>,
    ppc64: Option<()>,
    ppc64le: Option<()>,
    ppcemb: Option<()>,
    riscv32: Option<()>,
    riscv64: Option<()>,
    s390: Option<()>,
    s390x: Option<()>,
    sh4: Option<()>,
    sh4eb: Option<()>,
    sparc: Option<()>,
    sparc64: Option<()>,
    unicore32: Option<()>,
    xtensa: Option<()>,
    xtensaeb: Option<()>,
}
impl ArchChoiceBuilder {
    pub fn i686(&mut self) -> Result<&mut Self> {
        self.i686 = Some(());
        Ok(self)
    }
    pub fn x86_64(&mut self) -> Result<&mut Self> {
        self.x86_64 = Some(());
        Ok(self)
    }
    pub fn ia64(&mut self) -> Result<&mut Self> {
        self.ia64 = Some(());
        Ok(self)
    }
    pub fn aarch64(&mut self) -> Result<&mut Self> {
        self.aarch64 = Some(());
        Ok(self)
    }
    pub fn alpha(&mut self) -> Result<&mut Self> {
        self.alpha = Some(());
        Ok(self)
    }
    pub fn armv6l(&mut self) -> Result<&mut Self> {
        self.armv6l = Some(());
        Ok(self)
    }
    pub fn armv7l(&mut self) -> Result<&mut Self> {
        self.armv7l = Some(());
        Ok(self)
    }
    pub fn cris(&mut self) -> Result<&mut Self> {
        self.cris = Some(());
        Ok(self)
    }
    pub fn lm32(&mut self) -> Result<&mut Self> {
        self.lm32 = Some(());
        Ok(self)
    }
    pub fn loongarch64(&mut self) -> Result<&mut Self> {
        self.loongarch64 = Some(());
        Ok(self)
    }
    pub fn m68k(&mut self) -> Result<&mut Self> {
        self.m68k = Some(());
        Ok(self)
    }
    pub fn microblaze(&mut self) -> Result<&mut Self> {
        self.microblaze = Some(());
        Ok(self)
    }
    pub fn microblazeel(&mut self) -> Result<&mut Self> {
        self.microblazeel = Some(());
        Ok(self)
    }
    pub fn mips(&mut self) -> Result<&mut Self> {
        self.mips = Some(());
        Ok(self)
    }
    pub fn mipsel(&mut self) -> Result<&mut Self> {
        self.mipsel = Some(());
        Ok(self)
    }
    pub fn mips64(&mut self) -> Result<&mut Self> {
        self.mips64 = Some(());
        Ok(self)
    }
    pub fn mips64el(&mut self) -> Result<&mut Self> {
        self.mips64el = Some(());
        Ok(self)
    }
    pub fn openrisc(&mut self) -> Result<&mut Self> {
        self.openrisc = Some(());
        Ok(self)
    }
    pub fn parisc(&mut self) -> Result<&mut Self> {
        self.parisc = Some(());
        Ok(self)
    }
    pub fn parisc64(&mut self) -> Result<&mut Self> {
        self.parisc64 = Some(());
        Ok(self)
    }
    pub fn ppc(&mut self) -> Result<&mut Self> {
        self.ppc = Some(());
        Ok(self)
    }
    pub fn ppc64(&mut self) -> Result<&mut Self> {
        self.ppc64 = Some(());
        Ok(self)
    }
    pub fn ppc64le(&mut self) -> Result<&mut Self> {
        self.ppc64le = Some(());
        Ok(self)
    }
    pub fn ppcemb(&mut self) -> Result<&mut Self> {
        self.ppcemb = Some(());
        Ok(self)
    }
    pub fn riscv32(&mut self) -> Result<&mut Self> {
        self.riscv32 = Some(());
        Ok(self)
    }
    pub fn riscv64(&mut self) -> Result<&mut Self> {
        self.riscv64 = Some(());
        Ok(self)
    }
    pub fn s390(&mut self) -> Result<&mut Self> {
        self.s390 = Some(());
        Ok(self)
    }
    pub fn s390x(&mut self) -> Result<&mut Self> {
        self.s390x = Some(());
        Ok(self)
    }
    pub fn sh4(&mut self) -> Result<&mut Self> {
        self.sh4 = Some(());
        Ok(self)
    }
    pub fn sh4eb(&mut self) -> Result<&mut Self> {
        self.sh4eb = Some(());
        Ok(self)
    }
    pub fn sparc(&mut self) -> Result<&mut Self> {
        self.sparc = Some(());
        Ok(self)
    }
    pub fn sparc64(&mut self) -> Result<&mut Self> {
        self.sparc64 = Some(());
        Ok(self)
    }
    pub fn unicore32(&mut self) -> Result<&mut Self> {
        self.unicore32 = Some(());
        Ok(self)
    }
    pub fn xtensa(&mut self) -> Result<&mut Self> {
        self.xtensa = Some(());
        Ok(self)
    }
    pub fn xtensaeb(&mut self) -> Result<&mut Self> {
        self.xtensaeb = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<ArchChoice> {
        if self.i686.is_some() {
            return Ok(ArchChoice::I686);
        }
        if self.x86_64.is_some() {
            return Ok(ArchChoice::X8664);
        }
        if self.ia64.is_some() {
            return Ok(ArchChoice::Ia64);
        }
        if self.aarch64.is_some() {
            return Ok(ArchChoice::Aarch64);
        }
        if self.alpha.is_some() {
            return Ok(ArchChoice::Alpha);
        }
        if self.armv6l.is_some() {
            return Ok(ArchChoice::Armv6l);
        }
        if self.armv7l.is_some() {
            return Ok(ArchChoice::Armv7l);
        }
        if self.cris.is_some() {
            return Ok(ArchChoice::Cris);
        }
        if self.lm32.is_some() {
            return Ok(ArchChoice::Lm32);
        }
        if self.loongarch64.is_some() {
            return Ok(ArchChoice::Loongarch64);
        }
        if self.m68k.is_some() {
            return Ok(ArchChoice::M68k);
        }
        if self.microblaze.is_some() {
            return Ok(ArchChoice::Microblaze);
        }
        if self.microblazeel.is_some() {
            return Ok(ArchChoice::Microblazeel);
        }
        if self.mips.is_some() {
            return Ok(ArchChoice::Mips);
        }
        if self.mipsel.is_some() {
            return Ok(ArchChoice::Mipsel);
        }
        if self.mips64.is_some() {
            return Ok(ArchChoice::Mips64);
        }
        if self.mips64el.is_some() {
            return Ok(ArchChoice::Mips64el);
        }
        if self.openrisc.is_some() {
            return Ok(ArchChoice::Openrisc);
        }
        if self.parisc.is_some() {
            return Ok(ArchChoice::Parisc);
        }
        if self.parisc64.is_some() {
            return Ok(ArchChoice::Parisc64);
        }
        if self.ppc.is_some() {
            return Ok(ArchChoice::Ppc);
        }
        if self.ppc64.is_some() {
            return Ok(ArchChoice::Ppc64);
        }
        if self.ppc64le.is_some() {
            return Ok(ArchChoice::Ppc64le);
        }
        if self.ppcemb.is_some() {
            return Ok(ArchChoice::Ppcemb);
        }
        if self.riscv32.is_some() {
            return Ok(ArchChoice::Riscv32);
        }
        if self.riscv64.is_some() {
            return Ok(ArchChoice::Riscv64);
        }
        if self.s390.is_some() {
            return Ok(ArchChoice::S390);
        }
        if self.s390x.is_some() {
            return Ok(ArchChoice::S390x);
        }
        if self.sh4.is_some() {
            return Ok(ArchChoice::Sh4);
        }
        if self.sh4eb.is_some() {
            return Ok(ArchChoice::Sh4eb);
        }
        if self.sparc.is_some() {
            return Ok(ArchChoice::Sparc);
        }
        if self.sparc64.is_some() {
            return Ok(ArchChoice::Sparc64);
        }
        if self.unicore32.is_some() {
            return Ok(ArchChoice::Unicore32);
        }
        if self.xtensa.is_some() {
            return Ok(ArchChoice::Xtensa);
        }
        if self.xtensaeb.is_some() {
            return Ok(ArchChoice::Xtensaeb);
        }
        Err(Error::BuilderVariant("ArchChoice"))
    }
}

--- type/choice1.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Choice1 {
    Xen,
    Linux,
    Xenpvh,
}
impl ToXml for Choice1 {
    type Builder = Choice1Builder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Xen => {
                writer.write_event(Event::Text(BytesText::new("xen")))?;
            }
            Self::Linux => {
                writer.write_event(Event::Text(BytesText::new("linux")))?;
            }
            Self::Xenpvh => {
                writer.write_event(Event::Text(BytesText::new("xenpvh")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for Choice1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl Choice1 {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<Choice1> {
        let mut builder = Choice1::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "linux" => {
                                builder.linux()?;
                            }
                            "xen" => {
                                builder.xen()?;
                            }
                            "xenpvh" => {
                                builder.xenpvh()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Xen => {}
            Self::Linux => {}
            Self::Xenpvh => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for Choice1 {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "linux" => {
                builder.linux()?;
            }
            "xen" => {
                builder.xen()?;
            }
            "xenpvh" => {
                builder.xenpvh()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct Choice1Builder {
    xen: Option<()>,
    linux: Option<()>,
    xenpvh: Option<()>,
}
impl Choice1Builder {
    pub fn xen(&mut self) -> Result<&mut Self> {
        self.xen = Some(());
        Ok(self)
    }
    pub fn linux(&mut self) -> Result<&mut Self> {
        self.linux = Some(());
        Ok(self)
    }
    pub fn xenpvh(&mut self) -> Result<&mut Self> {
        self.xenpvh = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<Choice1> {
        if self.xen.is_some() {
            return Ok(Choice1::Xen);
        }
        if self.linux.is_some() {
            return Ok(Choice1::Linux);
        }
        if self.xenpvh.is_some() {
            return Ok(Choice1::Xenpvh);
        }
        Err(Error::BuilderVariant("Choice1"))
    }
}

--- type/choice2.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Choice2 {
    Xen,
    Linux,
    Xenpvh,
}
impl ToXml for Choice2 {
    type Builder = Choice2Builder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Xen => {
                writer.write_event(Event::Text(BytesText::new("xen")))?;
            }
            Self::Linux => {
                writer.write_event(Event::Text(BytesText::new("linux")))?;
            }
            Self::Xenpvh => {
                writer.write_event(Event::Text(BytesText::new("xenpvh")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for Choice2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl Choice2 {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<Choice2> {
        let mut builder = Choice2::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "linux" => {
                                builder.linux()?;
                            }
                            "xen" => {
                                builder.xen()?;
                            }
                            "xenpvh" => {
                                builder.xenpvh()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Xen => {}
            Self::Linux => {}
            Self::Xenpvh => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for Choice2 {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "linux" => {
                builder.linux()?;
            }
            "xen" => {
                builder.xen()?;
            }
            "xenpvh" => {
                builder.xenpvh()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct Choice2Builder {
    xen: Option<()>,
    linux: Option<()>,
    xenpvh: Option<()>,
}
impl Choice2Builder {
    pub fn xen(&mut self) -> Result<&mut Self> {
        self.xen = Some(());
        Ok(self)
    }
    pub fn linux(&mut self) -> Result<&mut Self> {
        self.linux = Some(());
        Ok(self)
    }
    pub fn xenpvh(&mut self) -> Result<&mut Self> {
        self.xenpvh = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<Choice2> {
        if self.xen.is_some() {
            return Ok(Choice2::Xen);
        }
        if self.linux.is_some() {
            return Ok(Choice2::Linux);
        }
        if self.xenpvh.is_some() {
            return Ok(Choice2::Xenpvh);
        }
        Err(Error::BuilderVariant("Choice2"))
    }
}

--- type/machine_choice.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MachineChoice {
    Xenpv,
    Xenfv,
    Xenpvh,
    Machine(
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern1>,
    ),
}
impl ToXml for MachineChoice {
    type Builder = MachineChoiceBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Xenpv => {
                writer.write_event(Event::Text(BytesText::new("xenpv")))?;
            }
            Self::Xenfv => {
                writer.write_event(Event::Text(BytesText::new("xenfv")))?;
            }
            Self::Xenpvh => {
                writer.write_event(Event::Text(BytesText::new("xenpvh")))?;
            }
            Self::Machine(machine) => {
                let elem = machine;
                {
                    let elem = machine;
                    writer.write_event(Event::Text(BytesText::new(&elem.to_string())))?;
                }
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for MachineChoice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl MachineChoice {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<MachineChoice> {
        let mut builder = MachineChoice::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "xenfv" => {
                                builder.xenfv()?;
                            }
                            "xenpv" => {
                                builder.xenpv()?;
                            }
                            "xenpvh" => {
                                builder.xenpvh()?;
                            }
                            val if val
                                .parse::<
                                    crate::ConstrainedString<
                                        0usize,
                                        18446744073709551615usize,
                                        crate::RegexPattern1,
                                    >,
                                >()
                                .is_ok() => {
                                builder
                                    .machine(
                                        val
                                            .parse::<
                                                crate::ConstrainedString<
                                                    0usize,
                                                    18446744073709551615usize,
                                                    crate::RegexPattern1,
                                                >,
                                            >()
                                            .map_err(|e| Error::ParseError("machine", Box::new(e)))?,
                                    )?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Xenpv => {}
            Self::Xenfv => {}
            Self::Xenpvh => {}
            Self::Machine(machine) => {
                let elem = machine;
            }
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for MachineChoice {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "xenfv" => {
                builder.xenfv()?;
            }
            "xenpv" => {
                builder.xenpv()?;
            }
            "xenpvh" => {
                builder.xenpvh()?;
            }
            val if val
                .parse::<
                    crate::ConstrainedString<
                        0usize,
                        18446744073709551615usize,
                        crate::RegexPattern1,
                    >,
                >()
                .is_ok() => {
                builder
                    .machine(
                        val
                            .parse::<
                                crate::ConstrainedString<
                                    0usize,
                                    18446744073709551615usize,
                                    crate::RegexPattern1,
                                >,
                            >()
                            .map_err(|e| Error::ParseError("machine", Box::new(e)))?,
                    )?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct MachineChoiceBuilder {
    xenpv: Option<()>,
    xenfv: Option<()>,
    xenpvh: Option<()>,
    machine: Option<
        crate::ConstrainedString<0usize, 18446744073709551615usize, crate::RegexPattern1>,
    >,
}
impl MachineChoiceBuilder {
    pub fn xenpv(&mut self) -> Result<&mut Self> {
        self.xenpv = Some(());
        Ok(self)
    }
    pub fn xenfv(&mut self) -> Result<&mut Self> {
        self.xenfv = Some(());
        Ok(self)
    }
    pub fn xenpvh(&mut self) -> Result<&mut Self> {
        self.xenpvh = Some(());
        Ok(self)
    }
    pub fn machine<T>(&mut self, machine: T) -> Result<&mut Self>
    where
        T: TryInto<
            crate::ConstrainedString<
                0usize,
                18446744073709551615usize,
                crate::RegexPattern1,
            >,
        >,
        Error: From<
            <T as TryInto<
                crate::ConstrainedString<
                    0usize,
                    18446744073709551615usize,
                    crate::RegexPattern1,
                >,
            >>::Error,
        >,
    {
        self.machine = Some(machine.try_into()?);
        Ok(self)
    }
    pub fn build(&self) -> Result<MachineChoice> {
        if self.xenpv.is_some() {
            return Ok(MachineChoice::Xenpv);
        }
        if self.xenfv.is_some() {
            return Ok(MachineChoice::Xenfv);
        }
        if self.xenpvh.is_some() {
            return Ok(MachineChoice::Xenpvh);
        }
        if self.machine.is_some() {
            return Ok(
                MachineChoice::Machine(Clone::clone(&self.machine.as_ref().unwrap())),
            );
        }
        Err(Error::BuilderVariant("MachineChoice"))
    }
}

--- type.rs ---
//!`type` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
pub mod arch_choice;
use arch_choice::ArchChoice;
pub mod choice1;
use choice1::Choice1;
pub mod choice2;
use choice2::Choice2;
pub mod machine_choice;
use machine_choice::MachineChoice;
///`<type/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Type {
    pub arch: Option<ArchChoice>,
    pub machine: Option<MachineChoice>,
    pub choice1: Option<Choice1>,
    pub choice2: Option<Choice2>,
}
impl ToXml for Type {
    type Builder = TypeBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("type");
        {
            let elem = &self.arch;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"arch"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        {
            let elem = &self.machine;
            if let Some(elem) = elem {
                xml_start
                    .push_attribute((
                        &b"machine"[..],
                        quick_xml::escape::escape(&elem.to_string()).as_bytes(),
                    ));
            }
        }
        {
            let elem = &self.choice1;
            if let Some(elem) = elem {
                elem.to_xml_attr(&mut xml_start)?;
            }
        }
        {
            let elem = &self.choice2;
            if let Some(elem) = elem {
                elem.to_xml_attr(&mut xml_start)?;
            }
        }
        let empty = {
            true
                && ({
                    let elem = &self.choice1;
                    elem.as_ref().map(|elem| elem.is_empty()).unwrap_or(true)
                })
                && ({
                    let elem = &self.choice2;
                    elem.as_ref().map(|elem| elem.is_empty()).unwrap_or(true)
                }) && (false)
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.choice1;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            {
                let elem = &self.choice2;
                if let Some(elem) = elem {
                    elem.to_xml(writer)?;
                }
            }
            writer.write_event(Event::Text(BytesText::new("hvm")))?;
            writer.write_event(Event::End(BytesEnd::new("type")))?;
        }
        Ok(())
    }
}
impl Type {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        if let Some(val) = node.attribute("arch") {
            builder.arch(Some(ArchChoice::from_str(val)?))?;
        }
        if let Some(val) = node.attribute("machine") {
            builder.machine(Some(MachineChoice::from_str(val)?))?;
        }
        for child in node.children() {
            match child.tag_name().name() {
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                "hvm" => {
                    builder.hvm()?;
                }
                _ => {}
            }
        }
        let child = &mut node.first_child();
        if let Ok(val) = Choice1::from_xml(node, child) {
            builder.choice1(Some(val))?;
        }
        let child = &mut node.first_child();
        if let Ok(val) = Choice2::from_xml(node, child) {
            builder.choice2(Some(val))?;
        }
        builder.build()
    }
}
impl core::fmt::Display for Type {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<type/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBuilder {
    pub arch: Option<ArchChoice>,
    pub machine: Option<MachineChoice>,
    pub choice1: Option<Choice1>,
    pub choice2: Option<Choice2>,
    pub hvm: Option<()>,
}
impl TypeBuilder {
    pub fn arch<T>(&mut self, arch: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<ArchChoice>,
        Error: From<<T as TryInto<ArchChoice>>::Error>,
    {
        self.arch = if let Some(arch) = arch { Some(arch.try_into()?) } else { None };
        Ok(self)
    }
    pub fn machine<T>(&mut self, machine: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<MachineChoice>,
        Error: From<<T as TryInto<MachineChoice>>::Error>,
    {
        self.machine = if let Some(machine) = machine {
            Some(machine.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn choice1<T>(&mut self, choice1: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Choice1>,
        Error: From<<T as TryInto<Choice1>>::Error>,
    {
        self.choice1 = if let Some(choice1) = choice1 {
            Some(choice1.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn choice2<T>(&mut self, choice2: Option<T>) -> Result<&mut Self>
    where
        T: TryInto<Choice2>,
        Error: From<<T as TryInto<Choice2>>::Error>,
    {
        self.choice2 = if let Some(choice2) = choice2 {
            Some(choice2.try_into()?)
        } else {
            None
        };
        Ok(self)
    }
    pub fn hvm(&mut self) -> Result<&mut Self> {
        self.hvm = Some(());
        Ok(self)
    }
    /**
            Attempt to build [`Type`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Type> {
        let arch = Clone::clone(&self.arch);
        let machine = Clone::clone(&self.machine);
        let choice1 = Clone::clone(&self.choice1);
        let choice2 = Clone::clone(&self.choice2);
        let hvm = Clone::clone(
            self.hvm.as_ref().ok_or(Error::BuilderMissingField("type", "hvm"))?,
        );
        Ok(Type {
            arch,
            machine,
            choice1,
            choice2,
        })
    }
}

--- vir_yes_no.rs ---
use crate::{Error, Result, ToXml};
use std::str::FromStr;
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum VirYesNo {
    Yes,
    No,
}
impl ToXml for VirYesNo {
    type Builder = VirYesNoBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{BytesEnd, BytesStart, BytesText, Event};
        match self {
            Self::Yes => {
                writer.write_event(Event::Text(BytesText::new("yes")))?;
            }
            Self::No => {
                writer.write_event(Event::Text(BytesText::new("no")))?;
            }
        }
        Ok(())
    }
}
impl core::fmt::Display for VirYesNo {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
impl VirYesNo {
    pub fn from_xml(
        node: &roxmltree::Node,
        from_child: &mut Option<roxmltree::Node>,
    ) -> Result<VirYesNo> {
        let mut builder = VirYesNo::builder();
        loop {
            let Some(child) = from_child else {
                break;
            };
            match child.node_type() {
                roxmltree::NodeType::Element => {
                    match child.tag_name().name() {
                        _ => {}
                    }
                }
                roxmltree::NodeType::Text => {
                    if let Some(val) = child.text() {
                        match val {
                            "no" => {
                                builder.no()?;
                            }
                            "yes" => {
                                builder.yes()?;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
            *from_child = child.next_sibling();
            if let Ok(build) = builder.build() {
                return Ok(build);
            }
        }
        builder.build()
    }
    pub fn to_xml_attr(
        &self,
        xml_start: &mut quick_xml::events::BytesStart<'_>,
    ) -> Result<()> {
        match self {
            Self::Yes => {}
            Self::No => {}
        }
        Ok(())
    }
    pub fn is_empty(&self) -> bool {
        self.to_string().is_empty()
    }
}
impl FromStr for VirYesNo {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut builder = Self::builder();
        match s {
            "no" => {
                builder.no()?;
            }
            "yes" => {
                builder.yes()?;
            }
            other => {
                dbg!(other);
            }
        }
        builder.build()
    }
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct VirYesNoBuilder {
    yes: Option<()>,
    no: Option<()>,
}
impl VirYesNoBuilder {
    pub fn yes(&mut self) -> Result<&mut Self> {
        self.yes = Some(());
        Ok(self)
    }
    pub fn no(&mut self) -> Result<&mut Self> {
        self.no = Some(());
        Ok(self)
    }
    pub fn build(&self) -> Result<VirYesNo> {
        if self.yes.is_some() {
            return Ok(VirYesNo::Yes);
        }
        if self.no.is_some() {
            return Ok(VirYesNo::No);
        }
        Err(Error::BuilderVariant("VirYesNo"))
    }
}
