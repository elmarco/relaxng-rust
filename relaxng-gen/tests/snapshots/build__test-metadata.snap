---
source: relaxng-gen/tests/build.rs
expression: combined
---
--- lib.rs ---
#![doc = concat!(
    "Generated from ",
    "'/home/elmarco/src/relaxng-rust/relaxng-gen/tests/fixtures/metadata.rng'",
    " schema."
)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use thiserror::Error;
pub mod metadata;
pub use metadata::*;
/// The error type used by this crate.
#[derive(Error, Debug)]
pub enum Error {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("From UTF-8 error: {0}")]
    FromUtf8Error(#[from] std::string::FromUtf8Error),
    #[error("{0} builder is missing mandatory field: {1}")]
    BuilderMissingField(&'static str, &'static str),
    #[error("{0} builder cannot build a variant")]
    BuilderVariant(&'static str),
    #[error("String too short, expected at least {0} characters, got {1}")]
    TooShort(usize, usize),
    #[error("String too long, expected at most {0} characters, got {1}")]
    TooLong(usize, usize),
    #[error("String '{0}' does not match pattern '{1}'")]
    PatternMismatch(&'static str, String),
    #[error("Failed to compile regex: {0}")]
    RegexError(#[from] regex::Error),
    #[error("Failed to parse '{0}': {1}")]
    ParseError(
        &'static str,
        #[source]
        Box<dyn std::error::Error + Send + Sync + 'static>,
    ),
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!("Infallible error should not occur")
    }
}
/// Helper trait for this crate XML types.
pub trait ToXml {
    /// The associated builder type.
    type Builder: Default;
    /// Creates a new builder for this type.
    fn builder() -> Self::Builder {
        Self::Builder::default()
    }
    /// Writes Events to a XML writer.
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write;
}
#[doc(hidden)]
pub trait RegexPattern {
    const REGEX: &'static str;
}
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NoPattern;
impl RegexPattern for NoPattern {
    const REGEX: &'static str = "";
}
/// A string type with length constraints and optional runtime regex validation.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstrainedString<
    const MIN_LEN: usize,
    const MAX_LEN: usize,
    P: RegexPattern = NoPattern,
> {
    value: String,
    _phantom: std::marker::PhantomData<P>,
}
impl<
    const MIN: usize,
    const MAX: usize,
    P: RegexPattern,
> ConstrainedString<MIN, MAX, P> {
    pub const NO_MIN_CONSTRAINT: usize = 0;
    pub const NO_MAX_CONSTRAINT: usize = usize::MAX;
    pub fn try_new(value: impl Into<String>) -> Result<Self> {
        let s = value.into();
        Self::validate(&s)?;
        Ok(Self {
            value: s,
            _phantom: std::marker::PhantomData,
        })
    }
    fn validate(s: &str) -> Result<()> {
        fn get_compiled_regex(pattern: &'static str) -> Result<regex::Regex> {
            /// Registry for compiled regex patterns
            static REGEX_REGISTRY: std::sync::OnceLock<
                std::sync::Mutex<std::collections::HashMap<&'static str, regex::Regex>>,
            > = std::sync::OnceLock::new();
            if pattern.is_empty() {
                return Ok(regex::Regex::new(".*").unwrap());
            }
            let registry = REGEX_REGISTRY
                .get_or_init(|| std::sync::Mutex::new(std::collections::HashMap::new()));
            let mut map = registry.lock().unwrap();
            if let Some(regex) = map.get(pattern) {
                return Ok(regex.clone());
            }
            match regex::Regex::new(pattern) {
                Ok(regex) => {
                    let result = regex.clone();
                    map.insert(pattern, regex);
                    Ok(result)
                }
                Err(e) => Err(Error::RegexError(e)),
            }
        }
        if MIN > Self::NO_MIN_CONSTRAINT && s.len() < MIN {
            return Err(Error::TooShort(MIN, s.len()));
        }
        if MAX < Self::NO_MAX_CONSTRAINT && s.len() > MAX {
            return Err(Error::TooLong(MAX, s.len()));
        }
        if !P::REGEX.is_empty() {
            let regex = get_compiled_regex(P::REGEX)?;
            if !regex.is_match(s) {
                return Err(Error::PatternMismatch(P::REGEX, s.to_string()));
            }
        }
        Ok(())
    }
    /// Returns the string as a `&str`.
    #[must_use]
    pub fn as_str(&self) -> &str {
        &self.value
    }
    /// Converts the constrained string into a `String`, consuming it.
    #[must_use]
    pub fn into_string(self) -> String {
        self.value
    }
}
impl<const MIN: usize, const MAX: usize, P: RegexPattern> std::ops::Deref
for ConstrainedString<MIN, MAX, P> {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        &self.value
    }
}
impl<const MIN: usize, const MAX: usize, P: RegexPattern> std::fmt::Display
for ConstrainedString<MIN, MAX, P> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.value)
    }
}
impl<const MIN: usize, const MAX: usize, P: RegexPattern> AsRef<str>
for ConstrainedString<MIN, MAX, P> {
    fn as_ref(&self) -> &str {
        &self.value
    }
}
impl<const MIN: usize, const MAX: usize, P: RegexPattern> std::str::FromStr
for ConstrainedString<MIN, MAX, P> {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self> {
        Self::try_new(s)
    }
}
/// Content that can appear inside an [`AnyElement`].
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AnyContent {
    /// A child element
    Element(AnyElement),
    /// Text content
    Text(String),
}
/// Represents an arbitrary XML element (for `anyName` patterns).
///
/// This type captures elements with any name, any attributes, and any content,
/// used when the schema allows arbitrary XML structure.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyElement {
    /// The element's local name
    pub name: String,
    /// The element's namespace URI, if any
    pub namespace: Option<String>,
    /// Attributes as (name, value) pairs
    pub attributes: Vec<(String, String)>,
    /// Child content: elements and text nodes
    pub children: Vec<AnyContent>,
}
impl AnyElement {
    /// Parse any XML node into an AnyElement
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let name = node.tag_name().name().to_string();
        let namespace = node.tag_name().namespace().map(|s| s.to_string());
        let attributes: Vec<_> = node
            .attributes()
            .map(|a| (a.name().to_string(), a.value().to_string()))
            .collect();
        let mut children = Vec::new();
        for child in node.children() {
            if child.is_element() {
                children.push(AnyContent::Element(AnyElement::from_xml(&child)?));
            } else if child.is_text() {
                if let Some(text) = child.text() {
                    if !text.trim().is_empty() {
                        children.push(AnyContent::Text(text.to_string()));
                    }
                }
            }
        }
        Ok(AnyElement {
            name,
            namespace,
            attributes,
            children,
        })
    }
}
impl ToXml for AnyElement {
    type Builder = AnyElementBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut start = BytesStart::new(&self.name);
        if let Some(ns) = &self.namespace {
            start.push_attribute(("xmlns", ns.as_str()));
        }
        for (key, value) in &self.attributes {
            start.push_attribute((key.as_str(), value.as_str()));
        }
        if self.children.is_empty() {
            writer.write_event(Event::Empty(start))?;
        } else {
            writer.write_event(Event::Start(start))?;
            for child in &self.children {
                match child {
                    AnyContent::Element(elem) => elem.to_xml(writer)?,
                    AnyContent::Text(text) => {
                        writer.write_event(Event::Text(BytesText::new(text)))?;
                    }
                }
            }
            writer.write_event(Event::End(BytesEnd::new(&self.name)))?;
        }
        Ok(())
    }
}
/// Builder for [`AnyElement`].
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyElementBuilder {
    name: Option<String>,
    namespace: Option<String>,
    attributes: Vec<(String, String)>,
    children: Vec<AnyContent>,
}
impl AnyElementBuilder {
    pub fn name(mut self, name: impl Into<String>) -> Self {
        self.name = Some(name.into());
        self
    }
    pub fn namespace(mut self, namespace: impl Into<String>) -> Self {
        self.namespace = Some(namespace.into());
        self
    }
    pub fn attribute(
        mut self,
        name: impl Into<String>,
        value: impl Into<String>,
    ) -> Self {
        self.attributes.push((name.into(), value.into()));
        self
    }
    pub fn child(mut self, child: AnyContent) -> Self {
        self.children.push(child);
        self
    }
    pub fn text(mut self, text: impl Into<String>) -> Self {
        self.children.push(AnyContent::Text(text.into()));
        self
    }
    pub fn element(mut self, element: AnyElement) -> Self {
        self.children.push(AnyContent::Element(element));
        self
    }
    pub fn build(self) -> Result<AnyElement> {
        Ok(AnyElement {
            name: self.name.ok_or(Error::BuilderMissingField("AnyElement", "name"))?,
            namespace: self.namespace,
            attributes: self.attributes,
            children: self.children,
        })
    }
}
/// A specialized Result type where the error is hard-wired to [`enum@Error`].
pub type Result<T, E = Error> = std::result::Result<T, E>;

--- main.rs ---
use std::path::Path;
use std::{env::args, fs};
fn main() {
    let path = args().nth(1).expect("No XML file path provided");
    let xml_path = Path::new(&path);
    let xml = fs::read_to_string(xml_path).expect("Failed to read test XML file");
    let xml = roxmltree::Document::parse(&xml).expect("Failed to parse XML");
    let root = xml.root().first_child().expect("No root element found");
    let res = test_metadata::Metadata::from_xml(&root).unwrap();
    let res = res.to_string();
    println!("{}", res);
}

--- metadata.rs ---
//!`metadata` module
use crate::{Error, Result, ToXml};
use std::str::FromStr;
///`<metadata/>` element
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Metadata {
    pub any_elements: Vec<crate::AnyElement>,
}
impl ToXml for Metadata {
    type Builder = MetadataBuilder;
    fn to_xml<W>(&self, writer: &mut quick_xml::Writer<W>) -> Result<()>
    where
        W: std::io::Write,
    {
        use quick_xml::events::{Event, BytesStart, BytesEnd, BytesText};
        let mut xml_start = BytesStart::new("metadata");
        let empty = {
            true
                && ({
                    let elem = &self.any_elements;
                    elem.iter().all(|elem| false)
                })
        };
        if empty {
            writer.write_event(Event::Empty(xml_start))?;
        } else {
            writer.write_event(Event::Start(xml_start))?;
            {
                let elem = &self.any_elements;
                for elem in elem {
                    elem.to_xml(writer)?;
                }
            }
            writer.write_event(Event::End(BytesEnd::new("metadata")))?;
        }
        Ok(())
    }
}
impl Metadata {
    pub fn from_xml(node: &roxmltree::Node) -> Result<Self> {
        let mut builder = Self::builder();
        for child in node.children() {
            match child.tag_name().name() {
                _ if child.is_element() => {
                    builder.any_element(crate::AnyElement::from_xml(&child)?)?;
                }
                _ => continue,
            }
        }
        if let Some(val) = node.text() {
            match val {
                _ => {}
            }
        }
        builder.build()
    }
}
impl core::fmt::Display for Metadata {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut writer = quick_xml::Writer::new_with_indent(
            std::io::Cursor::new(Vec::new()),
            b' ',
            2,
        );
        self.to_xml(&mut writer).expect("Failed to generate XML");
        let res = writer.into_inner().into_inner();
        let str = String::from_utf8(res).expect("Failed to convert bytes to string");
        f.write_str(&str)
    }
}
///`<metadata/>` builder
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetadataBuilder {
    pub any_elements: Vec<crate::AnyElement>,
}
impl MetadataBuilder {
    pub fn any_element<T>(&mut self, any_element: T) -> Result<&mut Self>
    where
        T: TryInto<crate::AnyElement>,
        Error: From<<T as TryInto<crate::AnyElement>>::Error>,
    {
        self.any_elements.push(any_element.try_into()?);
        Ok(self)
    }
    /**
            Attempt to build [`Metadata`].

            If the element is not valid, an error is returned.
            */
    pub fn build(&self) -> Result<Metadata> {
        let any_elements = Clone::clone(&self.any_elements);
        Ok(Metadata { any_elements })
    }
}
